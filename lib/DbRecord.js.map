{"version":3,"sources":["../src/DbRecord.js"],"names":["strcount","require","DbRecord","options","_autocommit","_raw","_changes","_tableName","constructor","_table","_locateField","_locatefield","dbh","_dbh","masterDbh","_init","auto","commit","sql","undefined","fields","values","Object","keys","forEach","field","push","join","res","querySync","insertId","_createAccessMethod","byKey","keyArgs","_keys","sort","commaSort","k","fits","split","kpart","_read","_readByKey","_initEmpty","autocommit","locateValue","rows","length","Error","console","log","Field","value","_accessField","ex","message","cb","where","qparam","match","ORDERBY","LIMIT","toString","DEBUG_SQL_QUERY","TOTAL","COUNTER","row","o","obj","a","b","ca"],"mappings":";;;;;;;;AAAA;;;;;;;;AACA,IAAMA,WAAWC,QAAQ,0BAAR,CAAjB;;AAEA;;;;IAGqBC,Q;;;2BACJ;AAAE,SAAM,oCAAN;AAA6C;;;iCACzC;AAAE,SAAM,oCAAN;AAA6C;;;0BACtD;AAAE,UAAO,EAAP;AAAY;;AAE7B;;;;;;;;;AAMA,qBAA0B;AAAA,MAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AACzB;;;AAGA,OAAKC,WAAL,GAAmB,IAAnB;AACA,OAAKC,IAAL,GAAY,EAAZ;AACA,OAAKC,QAAL,GAAgB,EAAhB;;AAEA,OAAKC,UAAL,GAAkB,KAAKC,WAAL,CAAiBC,MAAjB,EAAlB;AACA,OAAKC,YAAL,GAAoB,KAAKF,WAAL,CAAiBG,YAAjB,EAApB;;AAEA;AACA,MAAGR,QAAQS,GAAX,EAAgB;AACf,QAAKC,IAAL,GAAYV,QAAQS,GAApB;AACA,GAFD,MAEO;AACN,QAAKC,IAAL,GAAY,wBAAcC,SAAd,EAAZ;AACA;;AAED,OAAKC,KAAL,CAAWZ,OAAX;AACA;;AAGD;;;;;;;;;;;AAcA;;;;;6BAKWa,I,EAAM;AAChB,OAAGA,QAAQ,CAAC,KAAKZ,WAAjB,EAA8B;AAC7B;AACA,SAAKa,MAAL;AACA;AACD,QAAKb,WAAL,GAAmBY,IAAnB;AACA;;AAED;;;;;;2BAGS;AAAA;;AACR,OAAIE,MAAM,EAAV;;AAEA,OAAG,KAAKb,IAAL,CAAU,KAAKK,YAAf,MAAiCS,SAApC,EAA+C;AAC9CD,UAAM,SAAN;AACA,IAFD,MAEO;AACNA,UAAM,cAAN;AACA;;AAEDA,UAAU,KAAKX,UAAf;AACA,OAAMa,SAAS,EAAf;AACA,OAAMC,SAAS,EAAf;AACAC,UAAOC,IAAP,CAAY,KAAKjB,QAAjB,EAA2BkB,OAA3B,CAAmC,UAACC,KAAD,EAAW;AAC7CL,WAAOM,IAAP,CAAYD,QAAQ,IAApB;AACAJ,WAAOK,IAAP,CAAY,MAAKrB,IAAL,CAAUoB,KAAV,CAAZ;AACA,IAHD;;AAKAP,UAAOE,OAAOO,IAAP,CAAY,GAAZ,CAAP;;AAEA,OAAG,KAAKtB,IAAL,CAAU,KAAKK,YAAf,MAAiCS,SAApC,EAA+C;AAC9CD,uBAAiB,KAAKR,YAAtB;AACAW,WAAOK,IAAP,CAAY,KAAKrB,IAAL,CAAU,KAAKK,YAAf,CAAZ;AACA;;AAED,OAAIkB,MAAM,KAAKf,IAAL,CAAUgB,SAAV,CAAoBX,GAApB,EAAyBG,MAAzB,CAAV;AACA;AACA;AACA,OAAG,KAAKhB,IAAL,CAAU,KAAKK,YAAf,MAAiCS,SAApC,EAA+C;AAC9C,SAAKd,IAAL,CAAU,KAAKK,YAAf,IAA+BkB,IAAIE,QAAnC;AACA,SAAKC,mBAAL,CAAyB,KAAKrB,YAA9B;AACA;AACD;;AAED;;;;;;;;;;;;;wBAUMP,O,EAAS;AACd,OAAI6B,QAAQ,IAAZ;AACA,OAAMC,UAAU,EAAhB;;AAEA,QAAKzB,WAAL,CAAiB0B,KAAjB,GAAyBC,IAAzB,CAA8BC,SAA9B,EAAyCZ,OAAzC,CAAiD,UAACa,CAAD,EAAO;AACvD;AACA,QAAGL,SAAS,IAAZ,EAAkB;AAAE;AAAS;;AAE7B;AACA,QAAIM,OAAO,IAAX;AACAD,MAAEE,KAAF,CAAQ,GAAR,EAAaf,OAAb,CAAqB,UAACgB,KAAD,EAAW;AAC/B,SAAG,EAAEA,SAASrC,OAAX,CAAH,EAAwB;AAAEmC,aAAO,KAAP;AAAe;AACzC,KAFD;;AAIA,QAAGA,IAAH,EAAS;AACR;AACAN,aAAQK,EAAEE,KAAF,CAAQ,GAAR,CAAR;AACAP,WAAMR,OAAN,CAAc,UAACgB,KAAD,EAAW;AACxBP,cAAQP,IAAR,CAAavB,QAAQqC,KAAR,CAAb;AACA,MAFD;AAGA;AACD,IAjBD;;AAmBA;AACA,OAAGrC,QAAQ,KAAKO,YAAb,CAAH,EAA+B;AAC9B,SAAK+B,KAAL,CAAWtC,QAAQ,KAAKO,YAAb,CAAX;AACA,IAFD,MAGK,IAAGsB,KAAH,EAAU;AACd,SAAKU,UAAL,CAAgBV,KAAhB,EAAuBC,OAAvB;AACA,IAFI,MAGA;AACJ;AACA,SAAKU,UAAL;AACA,SAAKC,UAAL,CAAgB,KAAhB;AACA;AACD;;AAED;;;;;;;;;;;;wBASMC,W,EAAab,K,EAAO;AAAA;;AACzB,OAAIP,QAAQO,SAAS,KAAKtB,YAA1B;;AAEA,OAAMoC,OAAO,KAAKjC,IAAL,CAAUgB,SAAV,oBAAqC,KAAKtB,UAA1C,eAA8DkB,KAA9D,iBACZ,CAACoB,WAAD,CADY,CAAb;AAEA,OAAGC,KAAKC,MAAL,IAAe,CAAlB,EAAqB;AACpB,UAAM,IAAIC,KAAJ,CAAU,gBAAV,CAAN;AACA;;AAED,QAAK3C,IAAL,GAAYyC,KAAK,CAAL,CAAZ;;AAEA;AACAxB,UAAOC,IAAP,CAAY,KAAKlB,IAAjB,EAAuBmB,OAAvB,CAA+B,UAACC,KAAD,EAAW;AAAE,WAAKM,mBAAL,CAAyBN,KAAzB;AAAkC,IAA9E;AACA;;AAGD;;;;;;;;;6BAMWF,I,EAAMF,M,EAAQ;AAAA;;AACxB,OAAMD,SAASG,KAAKI,IAAL,CAAU,SAAV,IAAuB,IAAtC;;AAEAsB,WAAQC,GAAR,CAAY,IAAZ,EAAkB9B,MAAlB,EAA0BC,MAA1B;;AAEA,OAAMyB,OAAO,KAAKjC,IAAL,CAAUgB,SAAV,oBAAqC,KAAKtB,UAA1C,eAA8Da,MAA9D,eACZC,MADY,CAAb;AAEA,OAAGyB,KAAKC,MAAL,IAAe,CAAlB,EAAqB;AACpB,UAAM,IAAIC,KAAJ,CAAU,gBAAV,CAAN;AACA;;AAED,QAAK3C,IAAL,GAAYyC,KAAK,CAAL,CAAZ;;AAEA;AACAxB,UAAOC,IAAP,CAAY,KAAKlB,IAAjB,EAAuBmB,OAAvB,CAA+B,UAACC,KAAD,EAAW;AAAE,WAAKM,mBAAL,CAAyBN,KAAzB;AAAkC,IAA9E;AACA;;AAED;;;;;;;+BAIa;AAAA;;AACZ,OAAMqB,OAAO,KAAKjC,IAAL,CAAUgB,SAAV,eAAgC,KAAKtB,UAArC,CAAb;AACAuC,QAAKtB,OAAL,CAAa,UAACC,KAAD,EAAW;AAAE,WAAKM,mBAAL,CAAyBN,MAAM0B,KAA/B;AAAwC,IAAlE;AACA;;AAED;;;;;;;;;+BAMa1B,K,EAAO2B,K,EAAO;AAC1B;AACA;AACA,OAAGA,UAAU,IAAb,EAAmB;AAClB,SAAK9C,QAAL,CAAcmB,KAAd,IAAuB,IAAvB;AACA,SAAKpB,IAAL,CAAUoB,KAAV,IAAmB2B,KAAnB;;AAEA,QAAG,KAAKhD,WAAR,EAAqB;AACpB,UAAKa,MAAL;AACA;AACD;;AAED,UAAO,KAAKZ,IAAL,CAAUoB,KAAV,CAAP;AACA;;AAED;;;;;;;;sCAKoBA,K,EAAO;AAAA;;AAC1B,QAAKA,KAAL,IAAc,YAAkB;AAAA,QAAjB2B,KAAiB,uEAAT,IAAS;AAAE,WAAO,OAAKC,YAAL,CAAkB5B,KAAlB,EAAyB2B,KAAzB,CAAP;AAAyC,IAA3E;AACA;;AAGD;;;;;;;iCAIe;AACd,QAAKvC,IAAL,CAAUgB,SAAV,kBAAmC,KAAKtB,UAAxC,eAA4D,KAAKG,YAAjE,WACC,CAAE,KAAK,KAAKA,YAAV,GAAF,CADD;AAEA;;AAED;;;;;;;;;;;8BA1M+B;AAAA,OAAdP,OAAc,uEAAJ,EAAI;;AAC9B,OAAI;AACH,WAAO,IAAI,IAAJ,CAASA,OAAT,CAAP;AACA,IAFD,CAEE,OAAMmD,EAAN,EAAU;AACX,QAAGA,GAAGC,OAAH,IAAc,gBAAjB,EAAmC;AAAE,YAAO,IAAP;AAAc,KAAnD,MACK;AAAE,WAAMD,EAAN;AAAW;AAClB;AACD;;;0BA2McnD,O,EAASqD,E,EAAI;AAAA;;AAC3B,OAAItC,kBAAgB,KAAKP,YAAL,EAAhB,cAA4C,KAAKF,MAAL,EAAhD;AACA,OAAMgD,QAAQ,EAAd;AACA,OAAMC,SAAS,EAAf;;AAEA;AACApC,UAAOC,IAAP,CAAYpB,OAAZ,EAAqBqB,OAArB,CAA6B,UAACa,CAAD,EAAO;AACnC,QAAGA,EAAEsB,KAAF,CAAQ,aAAR,CAAH,EAA2B;AAAE;AAAS;;AAEtCF,UAAM/B,IAAN,CAAcW,CAAd;AACAqB,WAAOhC,IAAP,CAAYvB,QAAQkC,CAAR,CAAZ;AACA,IALD;;AAOA,OAAGoB,MAAMV,MAAN,GAAe,CAAlB,EAAqB;AACpB7B,WAAO,YAAYuC,MAAM9B,IAAN,CAAW,OAAX,CAAnB;AACA;;AAGD;AACA,OAAGxB,QAAQyD,OAAR,IAAmB,CAACzD,QAAQyD,OAAR,CAAgBD,KAAhB,CAAsB,kBAAtB,CAAvB,EAAkE;AACjEzC,WAAO,eAAef,QAAQyD,OAA9B;AACA;;AAED;AACA,OAAGzD,QAAQ0D,KAAR,IAAiB,CAAC1D,QAAQ0D,KAAR,CAAcC,QAAd,GAAyBH,KAAzB,CAA+B,UAA/B,CAArB,EAAiE;AAChEzC,WAAO,YAAYf,QAAQ0D,KAA3B;AACA;;AAED,OAAG1D,QAAQ4D,eAAX,EAA4B;AAC3Bd,YAAQC,GAAR,CAAYhC,GAAZ;AACA;;AAED;AACA;AACA,OAAML,OAAO,wBAAcC,SAAd,EAAb;AACA,OAAMgC,OAAOjC,KAAKgB,SAAL,CAAeX,GAAf,EAAoBwC,MAApB,CAAb;AACAvD,WAAQ6D,KAAR,GAAgBlB,KAAKC,MAArB;;AAEA,OAAGS,EAAH,EAAO;AACNrD,YAAQ8D,OAAR,GAAkB,CAAlB;;AAEAnB,SAAKtB,OAAL,CAAa,UAAC0C,GAAD,EAAS;AACrB/D,aAAQ8D,OAAR;;AAEA,SAAME,IAAI,EAAV;AACAA,OAAE,OAAKxD,YAAL,EAAF,IAAyBuD,IAAI,OAAKvD,YAAL,EAAJ,CAAzB;AACA,SAAMyD,MAAM,WAASD,CAAT,CAAZ;;AAEAX,QAAGY,GAAH,EAAQjE,OAAR;AACA,KARD;AASA,IAZD,MAYO;AACNA,YAAQ8D,OAAR,GAAkB9D,QAAQ6D,KAA1B;AACA;;AAED,UAAO7D,QAAQ8D,OAAf;AACA;;;;;;AAIF;;;;;;;kBAnTqB/D,Q;AAwTrB,SAASkC,SAAT,CAAmBiC,CAAnB,EAAqBC,CAArB,EAAwB;AACvB,KAAMC,KAAKvE,SAASqE,CAAT,EAAY,GAAZ,CAAX;AACA,KAAMb,KAAKxD,SAASsE,CAAT,EAAY,GAAZ,CAAX;AACA,QAAOC,KAAGf,EAAH,GAAO,CAAC,CAAR,GAAY,CAAnB;AACA","file":"DbRecord.js","sourcesContent":["import MysqlDatabase from \"./MysqlDatabase\";\nconst strcount = require('quickly-count-substrings');\n\n/**\n * Represents the database record class.\n**/\nexport default class DbRecord {\n\tstatic _table() { throw \"DbRecord can't be created directly\"; }\n\tstatic _locatefield() { throw \"DbRecord can't be created directly\"; }\n\tstatic _keys() { return []; }\n\n\t/**\n\t * Creates the class instance. If options.${_locatefield()} parameter is specified,\n\t * reads the data from the database and put them into the internal structures\n\t * (see _init() and _read())\n\t * @param {Object} [options]\n\t */\n\tconstructor(options = {}) {\n\t\t/**\n\t\t * The database handler to work with\n\t\t */\n\t\tthis._autocommit = true;\n\t\tthis._raw = {};\n\t\tthis._changes = {};\n\n\t\tthis._tableName = this.constructor._table();\n\t\tthis._locateField = this.constructor._locatefield();\n\n\t\t// Use either locally provided or database handler factory\n\t\tif(options.dbh) {\n\t\t\tthis._dbh = options.dbh;\n\t\t} else {\n\t\t\tthis._dbh = MysqlDatabase.masterDbh();\n\t\t}\n\n\t\tthis._init(options);\n\t}\n\n\n\t/**\n\t * Tries creating an object by locate field/keys. Unlike constructor, does\n\t * not throw an error for non-existing record and returns null instead.\n\t * @param options\n\t */\n\tstatic tryCreate(options = {}) {\n\t\ttry {\n\t\t\treturn new this(options);\n\t\t} catch(ex) {\n\t\t\tif(ex.message == \"E_DB_NO_OBJECT\") { return null; }\n\t\t\telse { throw ex; }\n\t\t}\n\t}\n\n\t/**\n\t * Instructs class to either save changes to db after each field update, or\n\t * accumulate the changes.\n\t * @param {boolean} auto\n\t */\n\tautocommit(auto) {\n\t\tif(auto && !this._autocommit) {\n\t\t\t// If there are potential unsaved changes, save them\n\t\t\tthis.commit();\n\t\t}\n\t\tthis._autocommit = auto;\n\t}\n\n\t/**\n\t * Save accumulated changed fields, if any\n\t */\n\tcommit() {\n\t\tlet sql = \"\";\n\n\t\tif(this._raw[this._locateField] !== undefined) {\n\t\t\tsql = \"UPDATE \";\n\t\t} else {\n\t\t\tsql = \"INSERT INTO \";\n\t\t}\n\n\t\tsql += `${this._tableName} SET `;\n\t\tconst fields = [];\n\t\tconst values = [];\n\t\tObject.keys(this._changes).forEach((field) => {\n\t\t\tfields.push(field + \"=?\");\n\t\t\tvalues.push(this._raw[field]);\n\t\t});\n\n\t\tsql += fields.join(\",\");\n\n\t\tif(this._raw[this._locateField] !== undefined) {\n\t\t\tsql += ` WHERE ${this._locateField}=?`;\n\t\t\tvalues.push(this._raw[this._locateField]);\n\t\t}\n\n\t\tvar res = this._dbh.querySync(sql, values);\n\t\t// During the first insert the ${_locatefield()} field will be empty, and,\n\t\t// probably, generated by mysql\n\t\tif(this._raw[this._locateField] === undefined) {\n\t\t\tthis._raw[this._locateField] = res.insertId;\n\t\t\tthis._createAccessMethod(this._locateField);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes class from the database or as an empty record.\n\t *\n\t * If 'options' contains a property named as _locatefield() defines, then we\n\t * try to initialize from the database. Exception is thrown if there's no\n\t * record found.\n\t *\n\t * @param options\n\t * @protected\n\t */\n\t_init(options) {\n\t\tlet byKey = null;\n\t\tconst keyArgs = [];\n\n\t\tthis.constructor._keys().sort(commaSort).forEach((k) => {\n\t\t\t// console.log(\"key\", k);\n\t\t\tif(byKey != null) { return; }\n\n\t\t\t// Check if all key parts are present\n\t\t\tlet fits = true;\n\t\t\tk.split(\",\").forEach((kpart) => {\n\t\t\t\tif(!(kpart in options)) { fits = false; }\n\t\t\t});\n\n\t\t\tif(fits) {\n\t\t\t\t// Key fits, remember it and its arguments\n\t\t\t\tbyKey = k.split(\",\");\n\t\t\t\tbyKey.forEach((kpart) => {\n\t\t\t\t\tkeyArgs.push(options[kpart]);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// if \"_locateField\" is set, then we need to read our data from the database\n\t\tif(options[this._locateField]) {\n\t\t\tthis._read(options[this._locateField]);\n\t\t}\n\t\telse if(byKey) {\n\t\t\tthis._readByKey(byKey, keyArgs);\n\t\t}\n\t\telse {\n\t\t\t// else create a new record: read the table info and build access methods\n\t\t\tthis._initEmpty();\n\t\t\tthis.autocommit(false);\n\t\t}\n\t}\n\n\t/**\n\t * Reads values from the database, puts them into _raw and creates a function\n\t * to get each value, so we can access fields as:\n\t * obj.field();\n\t * obj.field(\"new value\");\n\t * @protected\n\t * @param {*} locateValue - the database unique id of the record\n\t * @param {String} byKey - the field to search on. $_locateField by default.\n\t */\n\t_read(locateValue, byKey) {\n\t\tlet field = byKey || this._locateField;\n\n\t\tconst rows = this._dbh.querySync(`SELECT * FROM ${this._tableName} WHERE ${field}=? LIMIT 1`,\n\t\t\t[locateValue]);\n\t\tif(rows.length == 0) {\n\t\t\tthrow new Error(\"E_DB_NO_OBJECT\");\n\t\t}\n\n\t\tthis._raw = rows[0];\n\n\t\t// Create access methods for all fields\n\t\tObject.keys(this._raw).forEach((field) => { this._createAccessMethod(field); });\n\t}\n\n\n\t/**\n\t * Does the same work as _read, but accepts the secondary keys and values arrays\n\t * @param keys {Array}\n\t * @param values {Array}\n\t * @private\n\t */\n\t_readByKey(keys, values) {\n\t\tconst fields = keys.join(\"=? AND \") + \"=?\";\n\n\t\tconsole.log(\"q:\", fields, values);\n\n\t\tconst rows = this._dbh.querySync(`SELECT * FROM ${this._tableName} WHERE ${fields} LIMIT 1`,\n\t\t\tvalues);\n\t\tif(rows.length == 0) {\n\t\t\tthrow new Error(\"E_DB_NO_OBJECT\");\n\t\t}\n\n\t\tthis._raw = rows[0];\n\n\t\t// Create access methods for all fields\n\t\tObject.keys(this._raw).forEach((field) => { this._createAccessMethod(field); });\n\t}\n\n\t/**\n\t * Initializes an empty object\n\t * @private\n\t */\n\t_initEmpty() {\n\t\tconst rows = this._dbh.querySync(`DESCRIBE ${this._tableName}`);\n\t\trows.forEach((field) => { this._createAccessMethod(field.Field); });\n\t}\n\n\t/**\n\t * The template for access methods. Reads or sets the value of the object field.\n\t * @param field\n\t * @param value\n\t * @private\n\t */\n\t_accessField(field, value) {\n\t\t// We use the magic \"\\0\" instead of undefined for non-set value, because we may need\n\t\t// to set NULL field: class.field(null)\n\t\tif(value !== \"\\0\") {\n\t\t\tthis._changes[field] = true;\n\t\t\tthis._raw[field] = value;\n\n\t\t\tif(this._autocommit) {\n\t\t\t\tthis.commit();\n\t\t\t}\n\t\t}\n\n\t\treturn this._raw[field];\n\t}\n\n\t/**\n\t * Creates a function within this class to get/set the certain field\n\t * @param field\n\t * @private\n\t */\n\t_createAccessMethod(field) {\n\t\tthis[field] = (value = \"\\0\") => { return this._accessField(field, value); }\n\t}\n\n\n\t/**\n\t * Removes the record from the database. No verification or integrity checks\n\t * are being performed, they are up to caller.\n\t */\n\tdeleteRecord() {\n\t\tthis._dbh.querySync(`DELETE FROM ${this._tableName} WHERE ${this._locateField} = ?`,\n\t\t\t[ this[this._locateField]() ]);\n\t}\n\n\t/**\n\t * Runs through database objects according the options, and calls the\n\t * callback routine for each.\n\t *\n\t * @param options\n\t * @param {Function} cb - the callback function, it receives two arguments:\n\t * \tthe current iteration DbRecord and the \"options\" object\n\t */\n\tstatic forEach(options, cb) {\n\t\tlet sql = `SELECT ${this._locatefield()} FROM ${this._table()}`;\n\t\tconst where = [];\n\t\tconst qparam = [];\n\n\t\t// WHERE fields\n\t\tObject.keys(options).forEach((k) => {\n\t\t\tif(k.match(/[^a-z0-9._]/)) { return; }\n\n\t\t\twhere.push(`${k}=?`);\n\t\t\tqparam.push(options[k]);\n\t\t});\n\n\t\tif(where.length > 0) {\n\t\t\tsql += \" WHERE \" + where.join(\" AND \");\n\t\t}\n\n\n\t\t// ORDER BY\n\t\tif(options.ORDERBY && !options.ORDERBY.match(/[^a-zA-Z0-9 ><-]/)) {\n\t\t\tsql += \" ORDER BY \" + options.ORDERBY;\n\t\t}\n\n\t\t// LIMIT\n\t\tif(options.LIMIT && !options.LIMIT.toString().match(/[^0-9, ]/)) {\n\t\t\tsql += \" LIMIT \" + options.LIMIT;\n\t\t}\n\n\t\tif(options.DEBUG_SQL_QUERY) {\n\t\t\tconsole.log(sql);\n\t\t}\n\n\t\t//\n\t\t// Iterate\n\t\tconst _dbh = MysqlDatabase.masterDbh();\n\t\tconst rows = _dbh.querySync(sql, qparam);\n\t\toptions.TOTAL = rows.length;\n\n\t\tif(cb) {\n\t\t\toptions.COUNTER = 0;\n\n\t\t\trows.forEach((row) => {\n\t\t\t\toptions.COUNTER++;\n\n\t\t\t\tconst o = {};\n\t\t\t\to[this._locatefield()] = row[this._locatefield()];\n\t\t\t\tconst obj = new this(o);\n\n\t\t\t\tcb(obj, options);\n\t\t\t});\n\t\t} else {\n\t\t\toptions.COUNTER = options.TOTAL;\n\t\t}\n\n\t\treturn options.COUNTER;\n\t}\n}\n\n\n/**\n * The sorting function to get entries with more commas first\n * @param a\n * @param b\n */\nfunction commaSort(a,b) {\n\tconst ca = strcount(a, \",\");\n\tconst cb = strcount(b, \",\");\n\treturn ca>cb? -1 : 1;\n}\n"]}