{"version":3,"sources":["../src/DbRecord.js"],"names":["DbRecord","options","_autocommit","_raw","_changes","_tableName","constructor","_table","_locateField","_locatefield","dbh","_dbh","masterDbh","_init","auto","commit","sql","undefined","fields","values","Object","keys","forEach","field","push","join","res","querySync","insertId","_createAccessMethod","byKey","_keys","k","_read","_initEmpty","autocommit","locateValue","rows","length","Error","Field","value","_accessField","ex","message","cb","where","qparam","match","ORDERBY","LIMIT","toString","DEBUG_SQL_QUERY","console","log","TOTAL","COUNTER","row","o","obj"],"mappings":"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","file":"DbRecord.js","sourcesContent":["import MysqlDatabase from \"./MysqlDatabase\";\n\n/**\n * Represents the database record class.\n**/\nexport default class DbRecord {\n\tstatic _keys() { return []; }\n\n\t/**\n\t * Creates the class instance. If options.${_locatefield()} parameter is specified,\n\t * reads the data from the database and put them into the internal structures\n\t * (see _init() and _read())\n\t * @param {Object} [options]\n\t */\n\tconstructor(options = {}) {\n\t\t/**\n\t\t * The database handler to work with\n\t\t */\n\t\tthis._autocommit = true;\n\t\tthis._raw = {};\n\t\tthis._changes = {};\n\n\t\tthis._tableName = this.constructor._table();\n\t\tthis._locateField = this.constructor._locatefield();\n\n\t\t// Use either locally provided or database handler factory\n\t\tif(options.dbh) {\n\t\t\tthis._dbh = options.dbh;\n\t\t} else {\n\t\t\tthis._dbh = MysqlDatabase.masterDbh();\n\t\t}\n\n\t\tthis._init(options);\n\t}\n\n\n\t/**\n\t * Tries creating an object by locate field/keys. Unlike constructor, does\n\t * not throw an error for non-existing record and returns null instead.\n\t * @param options\n\t */\n\tstatic tryCreate(options = {}) {\n\t\ttry {\n\t\t\treturn new this(options);\n\t\t} catch(ex) {\n\t\t\tif(ex.message == \"E_DB_NO_OBJECT\") { return null; }\n\t\t\telse { throw ex; }\n\t\t}\n\t}\n\n\t/**\n\t * Instructs class to either save changes to db after each field update, or\n\t * accumulate the changes.\n\t * @param {boolean} auto\n\t */\n\tautocommit(auto) {\n\t\tif(auto && !this._autocommit) {\n\t\t\t// If there are potential unsaved changes, save them\n\t\t\tthis.commit();\n\t\t}\n\t\tthis._autocommit = auto;\n\t}\n\n\t/**\n\t * Save accumulated changed fields, if any\n\t */\n\tcommit() {\n\t\tlet sql = \"\";\n\n\t\tif(this._raw[this._locateField] !== undefined) {\n\t\t\tsql = \"UPDATE \";\n\t\t} else {\n\t\t\tsql = \"INSERT INTO \";\n\t\t}\n\n\t\tsql += `${this._tableName} SET `;\n\t\tconst fields = [];\n\t\tconst values = [];\n\t\tObject.keys(this._changes).forEach((field) => {\n\t\t\tfields.push(field + \"=?\");\n\t\t\tvalues.push(this._raw[field]);\n\t\t});\n\n\t\tsql += fields.join(\",\");\n\n\t\tif(this._raw[this._locateField] !== undefined) {\n\t\t\tsql += ` WHERE ${this._locateField}=?`;\n\t\t\tvalues.push(this._raw[this._locateField]);\n\t\t}\n\n\t\tvar res = this._dbh.querySync(sql, values);\n\t\t// During the first insert the ${_locatefield()} field will be empty, and,\n\t\t// probably, generated by mysql\n\t\tif(this._raw[this._locateField] === undefined) {\n\t\t\tthis._raw[this._locateField] = res.insertId;\n\t\t\tthis._createAccessMethod(this._locateField);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes class from the database or as an empty record.\n\t *\n\t * If 'options' contains a property named as _locatefield() defines, then we\n\t * try to initialize from the database. Exception is thrown if there's no\n\t * record found.\n\t *\n\t * @param options\n\t * @protected\n\t */\n\t_init(options) {\n\t\tlet byKey = null;\n\t\tthis.constructor._keys().forEach((k) => {\n\t\t\tif(options[k]) { byKey = k; }\n\t\t});\n\n\t\t// if \"_locateField\" is set, then we need to read our data from the database\n\t\tif(options[this._locateField]) {\n\t\t\tthis._read(options[this._locateField]);\n\t\t}\n\t\telse if(byKey) {\n\t\t\tthis._read(options[byKey], byKey);\n\t\t}\n\t\telse {\n\t\t\t// else create a new record: read the table info and build access methods\n\t\t\tthis._initEmpty();\n\t\t\tthis.autocommit(false);\n\t\t}\n\t}\n\n\t/**\n\t * Reads values from the database, puts them into _raw and creates a function\n\t * to get each value, so we can access fields as:\n\t * obj.field();\n\t * obj.field(\"new value\");\n\t * @protected\n\t * @param {*} locateValue - the database unique id of the record\n\t * @param {String} byKey - the field to search on. $_locateField by default.\n\t */\n\t_read(locateValue, byKey) {\n\t\tlet field = byKey || this._locateField;\n\n\t\tconst rows = this._dbh.querySync(`SELECT * FROM ${this._tableName} WHERE ${field}=? LIMIT 1`,\n\t\t\t[locateValue]);\n\t\tif(rows.length == 0) {\n\t\t\tthrow new Error(\"E_DB_NO_OBJECT\");\n\t\t}\n\n\t\tthis._raw = rows[0];\n\n\t\t// Create access methods for all fields\n\t\tObject.keys(this._raw).forEach((field) => { this._createAccessMethod(field); });\n\t}\n\n\t/**\n\t * Initializes an empty object\n\t * @private\n\t */\n\t_initEmpty() {\n\t\tconst rows = this._dbh.querySync(`DESCRIBE ${this._tableName}`);\n\t\trows.forEach((field) => { this._createAccessMethod(field.Field); });\n\t}\n\n\t/**\n\t * The template for access methods. Reads or sets the value of the object field.\n\t * @param field\n\t * @param value\n\t * @private\n\t */\n\t_accessField(field, value) {\n\t\t// We use the magic \"\\0\" instead of undefined for non-set value, because we may need\n\t\t// to set NULL field: class.field(null)\n\t\tif(value !== \"\\0\") {\n\t\t\tthis._changes[field] = true;\n\t\t\tthis._raw[field] = value;\n\n\t\t\tif(this._autocommit) {\n\t\t\t\tthis.commit();\n\t\t\t}\n\t\t}\n\n\t\treturn this._raw[field];\n\t}\n\n\t/**\n\t * Creates a function within this class to get/set the certain field\n\t * @param field\n\t * @private\n\t */\n\t_createAccessMethod(field) {\n\t\tthis[field] = (value = \"\\0\") => { return this._accessField(field, value); }\n\t}\n\n\n\t/**\n\t * Removes the record from the database. No verification or integrity checks\n\t * are being performed, they are up to caller.\n\t */\n\tdeleteRecord() {\n\t\tthis._dbh.querySync(`DELETE FROM ${this._tableName} WHERE ${this._locateField} = ?`,\n\t\t\t[ this[this._locateField]() ]);\n\t}\n\n\t/**\n\t * Runs through database objects according the options, and calls the\n\t * callback routine for each.\n\t *\n\t * @param options\n\t * @param {Function} cb - the callback function, it receives two arguments:\n\t * \tthe current iteration DbRecord and the \"options\" object\n\t */\n\tstatic forEach(options, cb) {\n\t\tlet sql = `SELECT ${this._locatefield()} FROM ${this._table()}`;\n\t\tconst where = [];\n\t\tconst qparam = [];\n\n\t\t// WHERE fields\n\t\tObject.keys(options).forEach((k) => {\n\t\t\tif(k.match(/[^a-z0-9._]/)) { return; }\n\n\t\t\twhere.push(`${k}=?`);\n\t\t\tqparam.push(options[k]);\n\t\t});\n\n\t\tif(where.length > 0) {\n\t\t\tsql += \" WHERE \" + where.join(\" AND \");\n\t\t}\n\n\n\t\t// ORDER BY\n\t\tif(options.ORDERBY && !options.ORDERBY.match(/[^a-zA-Z0-9 ><-]/)) {\n\t\t\tsql += \" ORDER BY \" + options.ORDERBY;\n\t\t}\n\n\t\t// LIMIT\n\t\tif(options.LIMIT && !options.LIMIT.toString().match(/[^0-9, ]/)) {\n\t\t\tsql += \" LIMIT \" + options.LIMIT;\n\t\t}\n\n\t\tif(options.DEBUG_SQL_QUERY) {\n\t\t\tconsole.log(sql);\n\t\t}\n\n\t\t//\n\t\t// Iterate\n\t\tconst _dbh = MysqlDatabase.masterDbh();\n\t\tconst rows = _dbh.querySync(sql, qparam);\n\t\toptions.TOTAL = rows.length;\n\n\t\tif(cb) {\n\t\t\toptions.COUNTER = 0;\n\n\t\t\trows.forEach((row) => {\n\t\t\t\toptions.COUNTER++;\n\n\t\t\t\tconst o = {};\n\t\t\t\to[this._locatefield()] = row[this._locatefield()];\n\t\t\t\tconst obj = new this(o);\n\n\t\t\t\tcb(obj, options);\n\t\t\t});\n\t\t} else {\n\t\t\toptions.COUNTER = options.TOTAL;\n\t\t}\n\n\t\treturn options.COUNTER;\n\t}\n}\n\n"]}