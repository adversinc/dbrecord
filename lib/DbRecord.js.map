{"version":3,"sources":["../src/DbRecord.js"],"names":["strcount","require","DbRecord","options","_autocommit","_raw","_changes","_super","_tableName","constructor","_table","_locateField","_locatefield","dbh","_dbh","masterDbh","_init","auto","commit","sql","undefined","fields","values","Object","keys","forEach","field","push","join","res","querySync","insertId","_createAccessMethod","byKey","keyArgs","_keys","sort","commaSort","k","fits","split","kpart","_read","_readByKey","_initEmpty","autocommit","locateValue","rows","_createFromRows","length","Error","Field","value","f","_accessField","ex","message","cb","where","qparam","match","ORDERBY","LIMIT","toString","DEBUG_SQL_QUERY","console","log","TOTAL","COUNTER","row","o","obj","a","b","ca"],"mappings":";;;;;;;;AAAA;;;;;;;;AACA,IAAMA,WAAWC,QAAQ,0BAAR,CAAjB;;AAEA;;;;IAGqBC,Q;;;2BACJ;AAAE,SAAM,oCAAN;AAA6C;;;iCACzC;AAAE,SAAM,oCAAN;AAA6C;;;0BACtD;AAAE,UAAO,EAAP;AAAY;;AAE7B;;;;;;;;;AAMA,qBAA0B;AAAA,MAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AACzB;;;AAGA,OAAKC,WAAL,GAAmB,IAAnB;AACA,OAAKC,IAAL,GAAY,EAAZ;AACA,OAAKC,QAAL,GAAgB,EAAhB;AACA,OAAKC,MAAL,GAAc,EAAd,CAPyB,CAOP;;AAElB,OAAKC,UAAL,GAAkB,KAAKC,WAAL,CAAiBC,MAAjB,EAAlB;AACA,OAAKC,YAAL,GAAoB,KAAKF,WAAL,CAAiBG,YAAjB,EAApB;;AAEA;AACA,MAAGT,QAAQU,GAAX,EAAgB;AACf,QAAKC,IAAL,GAAYX,QAAQU,GAApB;AACA,GAFD,MAEO;AACN,QAAKC,IAAL,GAAY,wBAAcC,SAAd,EAAZ;AACA;;AAED,OAAKC,KAAL,CAAWb,OAAX;AACA;;AAGD;;;;;;;;;;;AAcA;;;;;6BAKWc,I,EAAM;AAChB,OAAGA,QAAQ,CAAC,KAAKb,WAAjB,EAA8B;AAC7B;AACA,SAAKc,MAAL;AACA;AACD,QAAKd,WAAL,GAAmBa,IAAnB;AACA;;AAED;;;;;;2BAGS;AAAA;;AACR,OAAIE,MAAM,EAAV;;AAEA,OAAG,KAAKd,IAAL,CAAU,KAAKM,YAAf,MAAiCS,SAApC,EAA+C;AAC9CD,UAAM,SAAN;AACA,IAFD,MAEO;AACNA,UAAM,cAAN;AACA;;AAEDA,UAAU,KAAKX,UAAf;AACA,OAAMa,SAAS,EAAf;AACA,OAAMC,SAAS,EAAf;AACAC,UAAOC,IAAP,CAAY,KAAKlB,QAAjB,EAA2BmB,OAA3B,CAAmC,UAACC,KAAD,EAAW;AAC7CL,WAAOM,IAAP,CAAYD,QAAQ,IAApB;AACAJ,WAAOK,IAAP,CAAY,MAAKtB,IAAL,CAAUqB,KAAV,CAAZ;AACA,IAHD;;AAKAP,UAAOE,OAAOO,IAAP,CAAY,GAAZ,CAAP;;AAEA,OAAG,KAAKvB,IAAL,CAAU,KAAKM,YAAf,MAAiCS,SAApC,EAA+C;AAC9CD,uBAAiB,KAAKR,YAAtB;AACAW,WAAOK,IAAP,CAAY,KAAKtB,IAAL,CAAU,KAAKM,YAAf,CAAZ;AACA;;AAED,OAAIkB,MAAM,KAAKf,IAAL,CAAUgB,SAAV,CAAoBX,GAApB,EAAyBG,MAAzB,CAAV;AACA;AACA;AACA,OAAG,KAAKjB,IAAL,CAAU,KAAKM,YAAf,MAAiCS,SAApC,EAA+C;AAC9C,SAAKf,IAAL,CAAU,KAAKM,YAAf,IAA+BkB,IAAIE,QAAnC;;AAEA,QAAG,KAAK,KAAKpB,YAAV,MAA4BS,SAA/B,EAA0C;AACzC,UAAKY,mBAAL,CAAyB,KAAKrB,YAA9B;AACA;AACD;AACD;;AAED;;;;;;;;;;;;;wBAUMR,O,EAAS;AACd,OAAI8B,QAAQ,IAAZ;AACA,OAAMC,UAAU,EAAhB;;AAEA,QAAKzB,WAAL,CAAiB0B,KAAjB,GAAyBC,IAAzB,CAA8BC,SAA9B,EAAyCZ,OAAzC,CAAiD,UAACa,CAAD,EAAO;AACvD;AACA,QAAGL,SAAS,IAAZ,EAAkB;AAAE;AAAS;;AAE7B;AACA,QAAIM,OAAO,IAAX;AACAD,MAAEE,KAAF,CAAQ,GAAR,EAAaf,OAAb,CAAqB,UAACgB,KAAD,EAAW;AAC/B,SAAG,EAAEA,SAAStC,OAAX,CAAH,EAAwB;AAAEoC,aAAO,KAAP;AAAe;AACzC,KAFD;;AAIA,QAAGA,IAAH,EAAS;AACR;AACAN,aAAQK,EAAEE,KAAF,CAAQ,GAAR,CAAR;AACAP,WAAMR,OAAN,CAAc,UAACgB,KAAD,EAAW;AACxBP,cAAQP,IAAR,CAAaxB,QAAQsC,KAAR,CAAb;AACA,MAFD;AAGA;AACD,IAjBD;;AAmBA;AACA,OAAGtC,QAAQ,KAAKQ,YAAb,CAAH,EAA+B;AAC9B,SAAK+B,KAAL,CAAWvC,QAAQ,KAAKQ,YAAb,CAAX;AACA,IAFD,MAGK,IAAGsB,KAAH,EAAU;AACd,SAAKU,UAAL,CAAgBV,KAAhB,EAAuBC,OAAvB;AACA,IAFI,MAGA;AACJ;AACA,SAAKU,UAAL;AACA,SAAKC,UAAL,CAAgB,KAAhB;AACA;AACD;;AAED;;;;;;;;;;;;wBASMC,W,EAAab,K,EAAO;AACzB,OAAIP,QAAQO,SAAS,KAAKtB,YAA1B;;AAEA,OAAMoC,OAAO,KAAKjC,IAAL,CAAUgB,SAAV,oBAAqC,KAAKtB,UAA1C,eAA8DkB,KAA9D,iBACZ,CAACoB,WAAD,CADY,CAAb;AAEA,UAAO,KAAKE,eAAL,CAAqBD,IAArB,CAAP;AACA;;AAGD;;;;;;;;;6BAMWvB,I,EAAMF,M,EAAQ;AACxB,OAAMD,SAASG,KAAKI,IAAL,CAAU,SAAV,IAAuB,IAAtC;;AAEA,OAAMmB,OAAO,KAAKjC,IAAL,CAAUgB,SAAV,oBAAqC,KAAKtB,UAA1C,eAA8Da,MAA9D,eACZC,MADY,CAAb;AAEA,UAAO,KAAK0B,eAAL,CAAqBD,IAArB,CAAP;AACA;;AAGD;;;;;;;;kCAKgBA,I,EAAM;AAAA;;AACrB,OAAGA,KAAKE,MAAL,IAAe,CAAlB,EAAqB;AACpB,UAAM,IAAIC,KAAJ,CAAU,gBAAV,CAAN;AACA;;AAED,QAAK7C,IAAL,GAAY0C,KAAK,CAAL,CAAZ;;AAEA;AACAxB,UAAOC,IAAP,CAAY,KAAKnB,IAAjB,EAAuBoB,OAAvB,CAA+B,UAACC,KAAD,EAAW;AAAE,WAAKM,mBAAL,CAAyBN,KAAzB;AAAkC,IAA9E;AACA;;AAED;;;;;;;+BAIa;AAAA;;AACZ,OAAMqB,OAAO,KAAKjC,IAAL,CAAUgB,SAAV,eAAgC,KAAKtB,UAArC,CAAb;AACAuC,QAAKtB,OAAL,CAAa,UAACC,KAAD,EAAW;AAAE,WAAKM,mBAAL,CAAyBN,MAAMyB,KAA/B;AAAwC,IAAlE;AACA;;AAED;;;;;;;;;+BAMazB,K,EAAO0B,K,EAAO;AAC1B;AACA,OAAGA,UAAUhC,SAAb,EAAwB;AACvB,SAAKd,QAAL,CAAcoB,KAAd,IAAuB,IAAvB;AACA,SAAKrB,IAAL,CAAUqB,KAAV,IAAmB0B,KAAnB;;AAEA,QAAG,KAAKhD,WAAR,EAAqB;AACpB,UAAKc,MAAL;AACA;AACD;;AAED,UAAO,KAAKb,IAAL,CAAUqB,KAAV,CAAP;AACA;;AAED;;;;;;;;sCAKoBA,K,EAAO;AAAA;;AAC1B;AACA,OAAM2B,IAAI,SAAJA,CAAI,GAAuB;AAAA,QAAtBD,KAAsB,uEAAdhC,SAAc;AAAE,WAAO,OAAKkC,YAAL,CAAkB5B,KAAlB,EAAyB0B,KAAzB,CAAP;AAAyC,IAA5E;;AAEA;AACA;AACA,OAAG,OAAO,KAAK1B,KAAL,CAAP,KAAuB,UAA1B,EAAsC;AACrC,SAAKnB,MAAL,CAAYmB,KAAZ,IAAqB2B,CAArB;AACA,IAFD,MAEO;AACN,SAAK3B,KAAL,IAAc2B,CAAd;AACA;AACD;;AAGD;;;;;;;iCAIe;AACd,QAAKvC,IAAL,CAAUgB,SAAV,kBAAmC,KAAKtB,UAAxC,eAA4D,KAAKG,YAAjE,WACC,CAAE,KAAK,KAAKA,YAAV,GAAF,CADD;AAEA;;AAED;;;;;;;8BAtN+B;AAAA,OAAdR,OAAc,uEAAJ,EAAI;;AAC9B,OAAI;AACH,WAAO,IAAI,IAAJ,CAASA,OAAT,CAAP;AACA,IAFD,CAEE,OAAMoD,EAAN,EAAU;AACX,QAAGA,GAAGC,OAAH,IAAc,gBAAjB,EAAmC;AAAE,YAAO,IAAP;AAAc,KAAnD,MACK;AAAE,WAAMD,EAAN;AAAW;AAClB;AACD;;;8BAmNkB;AAClB,UAAO,wBAAcxC,SAAd,EAAP;AACA;;AAED;;;;;;;;;;;0BAQeZ,O,EAASsD,E,EAAI;AAAA;;AAC3B,OAAItC,kBAAgB,KAAKP,YAAL,EAAhB,cAA4C,KAAKF,MAAL,EAAhD;AACA,OAAMgD,QAAQ,EAAd;AACA,OAAMC,SAAS,EAAf;;AAEA;AACApC,UAAOC,IAAP,CAAYrB,OAAZ,EAAqBsB,OAArB,CAA6B,UAACa,CAAD,EAAO;AACnC,QAAGA,EAAEsB,KAAF,CAAQ,aAAR,CAAH,EAA2B;AAAE;AAAS;;AAEtCF,UAAM/B,IAAN,CAAcW,CAAd;AACAqB,WAAOhC,IAAP,CAAYxB,QAAQmC,CAAR,CAAZ;AACA,IALD;;AAOA,OAAGoB,MAAMT,MAAN,GAAe,CAAlB,EAAqB;AACpB9B,WAAO,YAAYuC,MAAM9B,IAAN,CAAW,OAAX,CAAnB;AACA;;AAGD;AACA,OAAGzB,QAAQ0D,OAAR,IAAmB,CAAC1D,QAAQ0D,OAAR,CAAgBD,KAAhB,CAAsB,kBAAtB,CAAvB,EAAkE;AACjEzC,WAAO,eAAehB,QAAQ0D,OAA9B;AACA;;AAED;AACA,OAAG1D,QAAQ2D,KAAR,IAAiB,CAAC3D,QAAQ2D,KAAR,CAAcC,QAAd,GAAyBH,KAAzB,CAA+B,UAA/B,CAArB,EAAiE;AAChEzC,WAAO,YAAYhB,QAAQ2D,KAA3B;AACA;;AAED,OAAG3D,QAAQ6D,eAAX,EAA4B;AAC3BC,YAAQC,GAAR,CAAY/C,GAAZ;AACA;;AAED;AACA;AACA,OAAML,OAAO,wBAAcC,SAAd,EAAb;AACA,OAAMgC,OAAOjC,KAAKgB,SAAL,CAAeX,GAAf,EAAoBwC,MAApB,CAAb;AACAxD,WAAQgE,KAAR,GAAgBpB,KAAKE,MAArB;;AAEA,OAAGQ,EAAH,EAAO;AACNtD,YAAQiE,OAAR,GAAkB,CAAlB;;AAEArB,SAAKtB,OAAL,CAAa,UAAC4C,GAAD,EAAS;AACrBlE,aAAQiE,OAAR;;AAEA,SAAME,IAAI,EAAV;AACAA,OAAE,OAAK1D,YAAL,EAAF,IAAyByD,IAAI,OAAKzD,YAAL,EAAJ,CAAzB;AACA,SAAM2D,MAAM,WAASD,CAAT,CAAZ;;AAEAb,QAAGc,GAAH,EAAQpE,OAAR;AACA,KARD;AASA,IAZD,MAYO;AACNA,YAAQiE,OAAR,GAAkBjE,QAAQgE,KAA1B;AACA;;AAED,UAAOhE,QAAQiE,OAAf;AACA;;;;;;AAIF;;;;;;;kBAxUqBlE,Q;AA6UrB,SAASmC,SAAT,CAAmBmC,CAAnB,EAAqBC,CAArB,EAAwB;AACvB,KAAMC,KAAK1E,SAASwE,CAAT,EAAY,GAAZ,CAAX;AACA,KAAMf,KAAKzD,SAASyE,CAAT,EAAY,GAAZ,CAAX;AACA,QAAOC,KAAGjB,EAAH,GAAO,CAAC,CAAR,GAAY,CAAnB;AACA","file":"DbRecord.js","sourcesContent":["import MysqlDatabase from \"./MysqlDatabase\";\r\nconst strcount = require('quickly-count-substrings');\r\n\r\n/**\r\n * Represents the database record class.\r\n**/\r\nexport default class DbRecord {\r\n\tstatic _table() { throw \"DbRecord can't be created directly\"; }\r\n\tstatic _locatefield() { throw \"DbRecord can't be created directly\"; }\r\n\tstatic _keys() { return []; }\r\n\r\n\t/**\r\n\t * Creates the class instance. If options.${_locatefield()} parameter is specified,\r\n\t * reads the data from the database and put them into the internal structures\r\n\t * (see _init() and _read())\r\n\t * @param {Object} [options]\r\n\t */\r\n\tconstructor(options = {}) {\r\n\t\t/**\r\n\t\t * The database handler to work with\r\n\t\t */\r\n\t\tthis._autocommit = true;\r\n\t\tthis._raw = {};\r\n\t\tthis._changes = {};\r\n\t\tthis._super = {}; // To hold the existing access method functions\r\n\r\n\t\tthis._tableName = this.constructor._table();\r\n\t\tthis._locateField = this.constructor._locatefield();\r\n\r\n\t\t// Use either locally provided or database handler factory\r\n\t\tif(options.dbh) {\r\n\t\t\tthis._dbh = options.dbh;\r\n\t\t} else {\r\n\t\t\tthis._dbh = MysqlDatabase.masterDbh();\r\n\t\t}\r\n\r\n\t\tthis._init(options);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Tries creating an object by locate field/keys. Unlike constructor, does\r\n\t * not throw an error for non-existing record and returns null instead.\r\n\t * @param options\r\n\t */\r\n\tstatic tryCreate(options = {}) {\r\n\t\ttry {\r\n\t\t\treturn new this(options);\r\n\t\t} catch(ex) {\r\n\t\t\tif(ex.message == \"E_DB_NO_OBJECT\") { return null; }\r\n\t\t\telse { throw ex; }\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Instructs class to either save changes to db after each field update, or\r\n\t * accumulate the changes.\r\n\t * @param {boolean} auto\r\n\t */\r\n\tautocommit(auto) {\r\n\t\tif(auto && !this._autocommit) {\r\n\t\t\t// If there are potential unsaved changes, save them\r\n\t\t\tthis.commit();\r\n\t\t}\r\n\t\tthis._autocommit = auto;\r\n\t}\r\n\r\n\t/**\r\n\t * Save accumulated changed fields, if any\r\n\t */\r\n\tcommit() {\r\n\t\tlet sql = \"\";\r\n\r\n\t\tif(this._raw[this._locateField] !== undefined) {\r\n\t\t\tsql = \"UPDATE \";\r\n\t\t} else {\r\n\t\t\tsql = \"INSERT INTO \";\r\n\t\t}\r\n\r\n\t\tsql += `${this._tableName} SET `;\r\n\t\tconst fields = [];\r\n\t\tconst values = [];\r\n\t\tObject.keys(this._changes).forEach((field) => {\r\n\t\t\tfields.push(field + \"=?\");\r\n\t\t\tvalues.push(this._raw[field]);\r\n\t\t});\r\n\r\n\t\tsql += fields.join(\",\");\r\n\r\n\t\tif(this._raw[this._locateField] !== undefined) {\r\n\t\t\tsql += ` WHERE ${this._locateField}=?`;\r\n\t\t\tvalues.push(this._raw[this._locateField]);\r\n\t\t}\r\n\r\n\t\tvar res = this._dbh.querySync(sql, values);\r\n\t\t// During the first insert the ${_locatefield()} field will be empty, and,\r\n\t\t// probably, generated by mysql\r\n\t\tif(this._raw[this._locateField] === undefined) {\r\n\t\t\tthis._raw[this._locateField] = res.insertId;\r\n\r\n\t\t\tif(this[this._locateField] === undefined) {\r\n\t\t\t\tthis._createAccessMethod(this._locateField);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes class from the database or as an empty record.\r\n\t *\r\n\t * If 'options' contains a property named as _locatefield() defines, then we\r\n\t * try to initialize from the database. Exception is thrown if there's no\r\n\t * record found.\r\n\t *\r\n\t * @param options\r\n\t * @protected\r\n\t */\r\n\t_init(options) {\r\n\t\tlet byKey = null;\r\n\t\tconst keyArgs = [];\r\n\r\n\t\tthis.constructor._keys().sort(commaSort).forEach((k) => {\r\n\t\t\t// console.log(\"key\", k);\r\n\t\t\tif(byKey != null) { return; }\r\n\r\n\t\t\t// Check if all key parts are present\r\n\t\t\tlet fits = true;\r\n\t\t\tk.split(\",\").forEach((kpart) => {\r\n\t\t\t\tif(!(kpart in options)) { fits = false; }\r\n\t\t\t});\r\n\r\n\t\t\tif(fits) {\r\n\t\t\t\t// Key fits, remember it and its arguments\r\n\t\t\t\tbyKey = k.split(\",\");\r\n\t\t\t\tbyKey.forEach((kpart) => {\r\n\t\t\t\t\tkeyArgs.push(options[kpart]);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// if \"_locateField\" is set, then we need to read our data from the database\r\n\t\tif(options[this._locateField]) {\r\n\t\t\tthis._read(options[this._locateField]);\r\n\t\t}\r\n\t\telse if(byKey) {\r\n\t\t\tthis._readByKey(byKey, keyArgs);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// else create a new record: read the table info and build access methods\r\n\t\t\tthis._initEmpty();\r\n\t\t\tthis.autocommit(false);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Reads values from the database, puts them into _raw and creates a function\r\n\t * to get each value, so we can access fields as:\r\n\t * obj.field();\r\n\t * obj.field(\"new value\");\r\n\t * @protected\r\n\t * @param {*} locateValue - the database unique id of the record\r\n\t * @param {String} byKey - the field to search on. $_locateField by default.\r\n\t */\r\n\t_read(locateValue, byKey) {\r\n\t\tlet field = byKey || this._locateField;\r\n\r\n\t\tconst rows = this._dbh.querySync(`SELECT * FROM ${this._tableName} WHERE ${field}=? LIMIT 1`,\r\n\t\t\t[locateValue]);\r\n\t\treturn this._createFromRows(rows);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Does the same work as _read, but accepts the secondary keys and values arrays\r\n\t * @param keys {Array}\r\n\t * @param values {Array}\r\n\t * @private\r\n\t */\r\n\t_readByKey(keys, values) {\r\n\t\tconst fields = keys.join(\"=? AND \") + \"=?\";\r\n\r\n\t\tconst rows = this._dbh.querySync(`SELECT * FROM ${this._tableName} WHERE ${fields} LIMIT 1`,\r\n\t\t\tvalues);\r\n\t\treturn this._createFromRows(rows);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Initialize object and methods from rows array\r\n\t * @param rows\r\n\t * @private\r\n\t */\r\n\t_createFromRows(rows) {\r\n\t\tif(rows.length == 0) {\r\n\t\t\tthrow new Error(\"E_DB_NO_OBJECT\");\r\n\t\t}\r\n\r\n\t\tthis._raw = rows[0];\r\n\r\n\t\t// Create access methods for all fields\r\n\t\tObject.keys(this._raw).forEach((field) => { this._createAccessMethod(field); });\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes an empty object\r\n\t * @private\r\n\t */\r\n\t_initEmpty() {\r\n\t\tconst rows = this._dbh.querySync(`DESCRIBE ${this._tableName}`);\r\n\t\trows.forEach((field) => { this._createAccessMethod(field.Field); });\r\n\t}\r\n\r\n\t/**\r\n\t * The template for access methods. Reads or sets the value of the object field.\r\n\t * @param field\r\n\t * @param value\r\n\t * @private\r\n\t */\r\n\t_accessField(field, value) {\r\n\t\t// To set NULL field: class.field(null)\r\n\t\tif(value !== undefined) {\r\n\t\t\tthis._changes[field] = true;\r\n\t\t\tthis._raw[field] = value;\r\n\r\n\t\t\tif(this._autocommit) {\r\n\t\t\t\tthis.commit();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this._raw[field];\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a function within this class to get/set the certain field\r\n\t * @param field\r\n\t * @private\r\n\t */\r\n\t_createAccessMethod(field) {\r\n\t\t//console.log(\"creating\", field, typeof this[field]);\r\n\t\tconst f = (value = undefined) => { return this._accessField(field, value); };\r\n\r\n\t\t// If access function already exists, do not overwrite it. Instead, add a function\r\n\t\t// to this._super object\r\n\t\tif(typeof this[field] === \"function\") {\r\n\t\t\tthis._super[field] = f;\r\n\t\t} else {\r\n\t\t\tthis[field] = f;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Removes the record from the database. No verification or integrity checks\r\n\t * are being performed, they are up to caller.\r\n\t */\r\n\tdeleteRecord() {\r\n\t\tthis._dbh.querySync(`DELETE FROM ${this._tableName} WHERE ${this._locateField} = ?`,\r\n\t\t\t[ this[this._locateField]() ]);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns master database handle currently in-use. To be used in static\r\n\t * methods of DbRecord\r\n\t */\r\n\tstatic masterDbh() {\r\n\t\treturn MysqlDatabase.masterDbh();\r\n\t}\r\n\r\n\t/**\r\n\t * Runs through database objects according the options, and calls the\r\n\t * callback routine for each.\r\n\t *\r\n\t * @param options\r\n\t * @param {Function} cb - the callback function, it receives two arguments:\r\n\t * \tthe current iteration DbRecord and the \"options\" object\r\n\t */\r\n\tstatic forEach(options, cb) {\r\n\t\tlet sql = `SELECT ${this._locatefield()} FROM ${this._table()}`;\r\n\t\tconst where = [];\r\n\t\tconst qparam = [];\r\n\r\n\t\t// WHERE fields\r\n\t\tObject.keys(options).forEach((k) => {\r\n\t\t\tif(k.match(/[^a-z0-9._]/)) { return; }\r\n\r\n\t\t\twhere.push(`${k}=?`);\r\n\t\t\tqparam.push(options[k]);\r\n\t\t});\r\n\r\n\t\tif(where.length > 0) {\r\n\t\t\tsql += \" WHERE \" + where.join(\" AND \");\r\n\t\t}\r\n\r\n\r\n\t\t// ORDER BY\r\n\t\tif(options.ORDERBY && !options.ORDERBY.match(/[^a-zA-Z0-9 ><-]/)) {\r\n\t\t\tsql += \" ORDER BY \" + options.ORDERBY;\r\n\t\t}\r\n\r\n\t\t// LIMIT\r\n\t\tif(options.LIMIT && !options.LIMIT.toString().match(/[^0-9, ]/)) {\r\n\t\t\tsql += \" LIMIT \" + options.LIMIT;\r\n\t\t}\r\n\r\n\t\tif(options.DEBUG_SQL_QUERY) {\r\n\t\t\tconsole.log(sql);\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t// Iterate\r\n\t\tconst _dbh = MysqlDatabase.masterDbh();\r\n\t\tconst rows = _dbh.querySync(sql, qparam);\r\n\t\toptions.TOTAL = rows.length;\r\n\r\n\t\tif(cb) {\r\n\t\t\toptions.COUNTER = 0;\r\n\r\n\t\t\trows.forEach((row) => {\r\n\t\t\t\toptions.COUNTER++;\r\n\r\n\t\t\t\tconst o = {};\r\n\t\t\t\to[this._locatefield()] = row[this._locatefield()];\r\n\t\t\t\tconst obj = new this(o);\r\n\r\n\t\t\t\tcb(obj, options);\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\toptions.COUNTER = options.TOTAL;\r\n\t\t}\r\n\r\n\t\treturn options.COUNTER;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * The sorting function to get entries with more commas first\r\n * @param a\r\n * @param b\r\n */\r\nfunction commaSort(a,b) {\r\n\tconst ca = strcount(a, \",\");\r\n\tconst cb = strcount(b, \",\");\r\n\treturn ca>cb? -1 : 1;\r\n}\r\n"]}