{"version":3,"sources":["../src/DbRecord.js"],"names":["DbRecord","options","_autocommit","_raw","_changes","_tableName","_table","_locatefield","dbh","_dbh","globalDbh","_init","auto","commit","sql","undefined","fields","values","Object","keys","forEach","field","push","join","res","querySync","insertId","_createAccessMethod","_read","_initEmpty","autocommit","locateValue","rows","length","Field","value","_accessField"],"mappings":"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","file":"DbRecord.js","sourcesContent":["import MysqlDatabase from \"./mysql-queries\";\n\n/**\n * Represents the database record class.\n *\n * INHERITING CLASSES\n *\n * Descendant classes has to provide at least following functions:\n * \t_table() { return \"db-table-name\"; }\n * \t_locatefield() { return \"unique-id-field-name\"; }\n *\n * \tEverything else is being done by this class.\n *\n * \tUSAGE\n *\n * \tThe instance of the class represents the database record. It can be used\n * \tin two ways: reading data and writing data (and also mixed read/write).\n *\n * \tREADING RECORDS\n *\n * \tTo read existing record, the unique record id has to be passed to the class\n * \tconstructor: var obj = new InheritedClass({ uniqueFieldName: 11111 }). After reading\n * \tthe record, class will create the required get/set functions to access\n * \tdatabase row fields (e.g. let v = obj->some_field())\n *\n * \tWRITING RECORDS\n *\n * \tObject can be modified by passing the new field value to get/set function:\n * \tobj->some_field(\"new value\");\n *\n * \tBy default, objects save new values to the db on each call. If multiple\n * \tfields are supposed to be set, the auto-commit feature can be turned off,\n * \tand commit() method called after finishing updates:\n * \tobj->autocommit(false);\n * \tobj->some_field1(\"new value 1\");\n * \tobj->some_field2(\"new value 2\");\n * \t...\n * \tobj->commit();\n *\n * \tCREATING RECORDS\n *\n * \tTo create the new record, the constructor is being called without\n * \tlocate-field argument: let obj = InheritedClass->();\n *\n * \tThe newly created object has auto-commit disabled, so setting the necessary\n * \tfields has to be ended by calling commit():\n *\n * \tlet obj = InheritedClass->();\n * \tobj->some_field1(\"new value 1\");\n * \tobj->some_field2(\"new value 2\");\n * \t...\n * \tobj->commit();\n *\n * \tUntil commit() is called, the value of locate-field of the new record is\n * \tnot know (obviously). During the commit(), class reads the new record ID\n * \tfrom mysql and sets it accordingly:\n *\n * \t...\n * \tobj->commit();\n * \tconsole.log(\"New object ID\", obj->id());\n */\nclass DbRecord {\n\t/**\n\t * Creates the class instance. If options._locatefield parameter is specified,\n\t * reads the data from the database and put them into the internal structures\n\t * (see _init() and _read())\n\t * @param {Object} [options]\n\t */\n\tconstructor(options = {}) {\n\t\t/**\n\t\t * The database handler to work with\n\t\t */\n\t\tthis._autocommit = true;\n\t\tthis._raw = {};\n\t\tthis._changes = {};\n\n\t\tthis._tableName = this._table();\n\t\tthis._locatefield = this._locatefield();\n\n\t\t// Use either locally provided or database handler factory\n\t\tif(options.dbh) {\n\t\t\tthis._dbh = options.dbh;\n\t\t} else {\n\t\t\tthis._dbh = MysqlDatabase.globalDbh();\n\t\t}\n\n\t\tthis._init(options);\n\t}\n\n\t/**\n\t * Instructs class to either save changes to db after each field update, or\n\t * accumulate the changes.\n\t * @param {boolean} auto\n\t */\n\tautocommit(auto) {\n\t\tif(auto && !this._autocommit) {\n\t\t\t// If there are potential unsaved changes, save them\n\t\t\tthis.commit();\n\t\t}\n\t\tthis._autocommit = auto;\n\t}\n\n\t/**\n\t * Save accumulated changed fields, if any\n\t */\n\tcommit() {\n\t\tlet sql = \"\";\n\n\t\tif(this._raw[this._locatefield] !== undefined) {\n\t\t\tsql = \"UPDATE \";\n\t\t} else {\n\t\t\tsql = \"INSERT INTO \";\n\t\t}\n\n\t\tsql += `${this._tableName} SET `;\n\t\tconst fields = [];\n\t\tconst values = [];\n\t\tObject.keys(this._changes).forEach((field) => {\n\t\t\tfields.push(field + \"=?\");\n\t\t\tvalues.push(this._raw[field]);\n\t\t});\n\n\t\tsql += fields.join(\",\");\n\n\t\tif(this._raw[this._locatefield] !== undefined) {\n\t\t\tsql += ` WHERE ${this._locatefield}=?`;\n\t\t\tvalues.push(this._raw[this._locatefield]);\n\t\t}\n\n\t\tvar res = this._dbh.querySync(sql, values);\n\t\t// During the first insert the _locatefield field will be empty, and,\n\t\t// probably, generated by mysql\n\t\tif(this._raw[this._locatefield] === undefined) {\n\t\t\tthis._raw[this._locatefield] = res.insertId;\n\t\t\tthis._createAccessMethod(this._locatefield);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes class from the database or as an empty record.\n\t *\n\t * If 'options' contains a property named as _locatefield() defines, then we\n\t * try to initialize from the database. Exception is thrown if there's no\n\t * record found.\n\t *\n\t * @param options\n\t * @protected\n\t */\n\t_init(options) {\n\t\t// if \"_locatefield\" is set, then we need to read our data from the database\n\t\tif(options[this._locatefield]) {\n\t\t\tthis._read(options[this._locatefield]);\n\t\t} else {\n\t\t\t// else create a new record: read the table info and build access methods\n\t\t\tthis._initEmpty();\n\t\t\tthis.autocommit(false);\n\t\t}\n\t}\n\n\t/**\n\t * Reads values from the database, puts them into _raw and creates a function\n\t * to get each value, so we can access fields as:\n\t * obj.field();\n\t * obj.field(\"new value\");\n\t * @protected\n\t * @param {*} locateValue - the database unique id of the record\n\t */\n\t_read(locateValue) {\n\t\tconst rows = this._dbh.querySync(`SELECT * FROM ${this._tableName} WHERE ${this._locatefield}=? LIMIT 1`,\n\t\t\t[locateValue]);\n\t\tif(rows.length == 0) {\n\t\t\tthrow \"E_DB_NO_OBJECT\";\n\t\t}\n\n\t\tthis._raw = rows[0];\n\n\t\t// Create access methods for all fields\n\t\tObject.keys(this._raw).forEach((field) => { this._createAccessMethod(field); });\n\t}\n\n\t/**\n\t * Initializes an empty object\n\t * @private\n\t */\n\t_initEmpty() {\n\t\tconst rows = this._dbh.querySync(`DESCRIBE ${this._tableName}`);\n\t\trows.forEach((field) => { this._createAccessMethod(field.Field); });\n\t}\n\n\t/**\n\t * The template for access methods. Reads or sets the value of the object field.\n\t * @param field\n\t * @param value\n\t * @private\n\t */\n\t_accessField(field, value) {\n\t\t// We use the magic \"\\0\" instead of undefined for non-set value, because we may need\n\t\t// to set NULL field: class.field(null)\n\t\tif(value !== \"\\0\") {\n\t\t\tthis._changes[field] = true;\n\t\t\tthis._raw[field] = value;\n\n\t\t\tif(this._autocommit) {\n\t\t\t\tthis.commit();\n\t\t\t}\n\t\t}\n\n\t\treturn this._raw[field];\n\t}\n\n\t/**\n\t * Creates a function within this class to get/set the certain field\n\t * @param field\n\t * @private\n\t */\n\t_createAccessMethod(field) {\n\t\tthis[field] = (value = \"\\0\") => { return this._accessField(field, value); }\n\t}\n}\n\n\nexport { DbRecord };\n"]}