{"version":3,"sources":["../src/DbRecord.js"],"names":["DbRecord","options","_autocommit","_raw","_changes","_tableName","_table","_locatefield","dbh","_dbh","masterDbh","_init","auto","commit","sql","undefined","fields","values","Object","keys","forEach","field","push","join","res","querySync","insertId","_createAccessMethod","byKey","_keys","k","_read","_initEmpty","autocommit","locateValue","rows","length","Error","Field","value","_accessField","ex","message"],"mappings":"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","file":"DbRecord.js","sourcesContent":["import MysqlDatabase from \"./MysqlDatabase\";\n\n/**\n * Represents the database record class.\n**/\nexport default class DbRecord {\n\t_keys() { return []; }\n\n\t/**\n\t * Creates the class instance. If options._locatefield parameter is specified,\n\t * reads the data from the database and put them into the internal structures\n\t * (see _init() and _read())\n\t * @param {Object} [options]\n\t */\n\tconstructor(options = {}) {\n\t\t/**\n\t\t * The database handler to work with\n\t\t */\n\t\tthis._autocommit = true;\n\t\tthis._raw = {};\n\t\tthis._changes = {};\n\n\t\tthis._tableName = this._table();\n\t\tthis._locatefield = this._locatefield();\n\n\t\t// Use either locally provided or database handler factory\n\t\tif(options.dbh) {\n\t\t\tthis._dbh = options.dbh;\n\t\t} else {\n\t\t\tthis._dbh = MysqlDatabase.masterDbh();\n\t\t}\n\n\t\tthis._init(options);\n\t}\n\n\n\t/**\n\t * Tries creating an object by locate field/keys. Unlike constructor, does\n\t * not throw an error for non-existing record and returns null instead.\n\t * @param options\n\t */\n\tstatic tryCreate(options = {}) {\n\t\ttry {\n\t\t\treturn new this(options);\n\t\t} catch(ex) {\n\t\t\tif(ex.message == \"E_DB_NO_OBJECT\") { return null; }\n\t\t\telse { throw ex; }\n\t\t}\n\t}\n\n\t/**\n\t * Instructs class to either save changes to db after each field update, or\n\t * accumulate the changes.\n\t * @param {boolean} auto\n\t */\n\tautocommit(auto) {\n\t\tif(auto && !this._autocommit) {\n\t\t\t// If there are potential unsaved changes, save them\n\t\t\tthis.commit();\n\t\t}\n\t\tthis._autocommit = auto;\n\t}\n\n\t/**\n\t * Save accumulated changed fields, if any\n\t */\n\tcommit() {\n\t\tlet sql = \"\";\n\n\t\tif(this._raw[this._locatefield] !== undefined) {\n\t\t\tsql = \"UPDATE \";\n\t\t} else {\n\t\t\tsql = \"INSERT INTO \";\n\t\t}\n\n\t\tsql += `${this._tableName} SET `;\n\t\tconst fields = [];\n\t\tconst values = [];\n\t\tObject.keys(this._changes).forEach((field) => {\n\t\t\tfields.push(field + \"=?\");\n\t\t\tvalues.push(this._raw[field]);\n\t\t});\n\n\t\tsql += fields.join(\",\");\n\n\t\tif(this._raw[this._locatefield] !== undefined) {\n\t\t\tsql += ` WHERE ${this._locatefield}=?`;\n\t\t\tvalues.push(this._raw[this._locatefield]);\n\t\t}\n\n\t\tvar res = this._dbh.querySync(sql, values);\n\t\t// During the first insert the _locatefield field will be empty, and,\n\t\t// probably, generated by mysql\n\t\tif(this._raw[this._locatefield] === undefined) {\n\t\t\tthis._raw[this._locatefield] = res.insertId;\n\t\t\tthis._createAccessMethod(this._locatefield);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes class from the database or as an empty record.\n\t *\n\t * If 'options' contains a property named as _locatefield() defines, then we\n\t * try to initialize from the database. Exception is thrown if there's no\n\t * record found.\n\t *\n\t * @param options\n\t * @protected\n\t */\n\t_init(options) {\n\t\tlet byKey = null;\n\t\tthis._keys().forEach((k) => {\n\t\t\tif(options[k]) { byKey = k; }\n\t\t});\n\n\t\t// if \"_locatefield\" is set, then we need to read our data from the database\n\t\tif(options[this._locatefield]) {\n\t\t\tthis._read(options[this._locatefield]);\n\t\t}\n\t\telse if(byKey) {\n\t\t\tthis._read(options[byKey], byKey);\n\t\t}\n\t\telse {\n\t\t\t// else create a new record: read the table info and build access methods\n\t\t\tthis._initEmpty();\n\t\t\tthis.autocommit(false);\n\t\t}\n\t}\n\n\t/**\n\t * Reads values from the database, puts them into _raw and creates a function\n\t * to get each value, so we can access fields as:\n\t * obj.field();\n\t * obj.field(\"new value\");\n\t * @protected\n\t * @param {*} locateValue - the database unique id of the record\n\t * @param {String} byKey - the field to search on. $_locatefield by default.\n\t */\n\t_read(locateValue, byKey) {\n\t\tlet field = byKey || this._locatefield;\n\n\t\tconst rows = this._dbh.querySync(`SELECT * FROM ${this._tableName} WHERE ${field}=? LIMIT 1`,\n\t\t\t[locateValue]);\n\t\tif(rows.length == 0) {\n\t\t\tthrow new Error(\"E_DB_NO_OBJECT\");\n\t\t}\n\n\t\tthis._raw = rows[0];\n\n\t\t// Create access methods for all fields\n\t\tObject.keys(this._raw).forEach((field) => { this._createAccessMethod(field); });\n\t}\n\n\t/**\n\t * Initializes an empty object\n\t * @private\n\t */\n\t_initEmpty() {\n\t\tconst rows = this._dbh.querySync(`DESCRIBE ${this._tableName}`);\n\t\trows.forEach((field) => { this._createAccessMethod(field.Field); });\n\t}\n\n\t/**\n\t * The template for access methods. Reads or sets the value of the object field.\n\t * @param field\n\t * @param value\n\t * @private\n\t */\n\t_accessField(field, value) {\n\t\t// We use the magic \"\\0\" instead of undefined for non-set value, because we may need\n\t\t// to set NULL field: class.field(null)\n\t\tif(value !== \"\\0\") {\n\t\t\tthis._changes[field] = true;\n\t\t\tthis._raw[field] = value;\n\n\t\t\tif(this._autocommit) {\n\t\t\t\tthis.commit();\n\t\t\t}\n\t\t}\n\n\t\treturn this._raw[field];\n\t}\n\n\t/**\n\t * Creates a function within this class to get/set the certain field\n\t * @param field\n\t * @private\n\t */\n\t_createAccessMethod(field) {\n\t\tthis[field] = (value = \"\\0\") => { return this._accessField(field, value); }\n\t}\n}\n\n"]}