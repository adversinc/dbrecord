{"version":3,"sources":["../src/mysql-queries.js"],"names":["Future","require","lodashMerge","mysql","querySync","query","values","dbh","globalConfig","globalDbh","MysqlDatabase","config","_config","_db","createConnection","_transacted","_seq","Math","random","cb","connect","future","err","return","wait","end","trxDb","destroy","setTimeout","process","exit","Promise","resolve","reject","res","q","rows","length","ex","rollback","commit","removeHandlers","connectSync"],"mappings":"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","file":"mysql-queries.js","sourcesContent":["const\n\tFuture = require( 'fibers/future' ),\n\tlodashMerge = require('lodash/merge'),\n\tmysql = require('mysql');\n\nfunction querySync(query, values) {\n\treturn dbh.querySync(query, values);\n}\n\nlet globalConfig = {};\nlet globalDbh = null;\n\n/**\n * The database processing class.\n *\n * Transaction processing\n *\n * The problem is that all queries share the same mysql connection. Thus, even\n * if we have started the transaction, other queries can intervene within it.\n *\n * To avoid this, we create a separate connection when calling code starts\n * transaction. Then we return the new database handle (\"transacted\") to use,\n * and commit/rollback at the end.\n *\n * var dbh = dbh.beginTransaction(); // new dbh is created here\n * ....\n * dbh.commit();\n */\nclass MysqlDatabase {\n\tconstructor(config) {\n\t\t//console.log(\"created MysqlDatabase:\", db);\n\t\tthis._config = lodashMerge({}, config);\n\t\tthis._db = mysql.createConnection(this._config);\n\t\tthis._transacted = 0;\n\t\tthis._seq = Math.random();\n\t}\n\n\tconnect(cb) {\n\t\tthis._db.connect(cb);\n\t}\n\n\tconnectSync() {\n\t\tconst future = new Future();\n\t\tthis.connect((err) => {\n\t\t\tif(err) {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\tfuture.return();\n\t\t});\n\n\t\treturn future.wait();\n\t}\n\n\tdisconnect() {\n\t\tthis._db.end();\n\t}\n\n\tcloseAndExit() {\n\t\ttrxDb.destroy();\n\t\tsetTimeout(() => { process.exit(); }, 500);\n\t}\n\n\tquery(query, values, cb) {\n\t\treturn this._db.query(query, values, cb);\n\t}\n\n\tqueryAsync(query, values) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.query(query, values, (err, res) => {\n\t\t\t\tresolve(res);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Runs a select query synchronously and returns the results\n\t * @param query - query to run\n\t * @param values - values to be passed to query\n\t */\n\tquerySync(query, values) {\n\t\tconst future = new Future();\n\n\t\t// console.log(\"query\", this._transacted?\"(TRX)\":\"\", query);\n\n\t\tthis._db.query(query, values, (err, q) => {\n\t\t\tif(err) {\n\t\t\t\tthrow err;\n\t\t\t\tfuture.return(err);\n\t\t\t} else {\n\t\t\t\tfuture.return(q);\n\t\t\t}\n\t\t});\n\n\t\treturn future.wait();\n\t}\n\n\t/**\n\t * A shortcut function to get a single rows without messing with row arrays\n\t *\n\t * @param query\n\t * @param values\n\t * @returns {Object} - the object with selected fields or {} of no rows found\n\t */\n\tgetRowSync(query, values) {\n\t\tconst rows = this.querySync(query, values);\n\t\t// It is questionable: should we return {} or null below? Which is easier to use?\n\t\t// {} seems to be safer to use, no null.field error will fire\n\t\tif(rows.length === 0) { return {}; }\n\n\t\treturn rows[0];\n\t}\n\n\t/**\n\t * Begins the database transaction\n\t * @param {Function} cb - the callback to call. Should return 'false' if\n\t * \ttransaction should be rolled back\n\t */\n\texecTransaction(cb) {\n\t\t// TODO GG: port the nested trasactions code here\n\t\tif(this._transacted == 0) {\n\t\t\t// Create another connection\n\t\t\t//const trxDb = new MysqlDatabase(mysql.createConnection(Meteor.settings.mysql));\n\t\t\tconst trxDb = this;\n\n\t\t\ttrxDb.querySync(\"START TRANSACTION  /* from trx */\");\n\t\t\ttrxDb._transacted++;\n\n\t\t\tlet res = false;\n\t\t\ttry {\n\t\t\t\tres = cb(this);\n\t\t\t} catch(ex) {\n\t\t\t\ttrxDb.rollback();\n\t\t\t\tthrow ex;\n\t\t\t}\n\n\t\t\tif(res === false) {\n\t\t\t\ttrxDb.rollback();\n\t\t\t} else {\n\t\t\t\ttrxDb.commit();\n\t\t\t}\n\n\t\t\treturn trxDb;\n\t\t}\n\t}\n\n\t/**\n\t * Commits the current database transaction\n\t */\n\tcommit() {\n\t\tif(this._transacted > 0) {\n\t\t\tthis._transacted--;\n\t\t\tthis.querySync(\"COMMIT /* from trx */\");\n\t\t}\n\t}\n\n\t/**\n\t * Rolls back the current database transaction\n\t */\n\trollback() {\n\t\tif(this._transacted > 0) {\n\t\t\tthis._transacted--;\n\t\t\tthis.querySync(\"ROLLBACK /* from trx */\");\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tthis._db.destroy();\n\t\tthis.removeHandlers();\n\t}\n\n\n\t/**\n\t * The connection configuration for globalDbh\n\t * @param config\n\t */\n\tstatic globalConfig(config) {\n\t\tglobalConfig = config;\n\t}\n\n\t/**\n\t * The connection factory. Creates a global connection to be used by default\n\t */\n\tstatic globalDbh() {\n\t\tif(!globalDbh) {\n\t\t\tglobalDbh = new MysqlDatabase(globalConfig);\n\t\t\tglobalDbh.connectSync();\n\t\t}\n\n\t\treturn globalDbh;\n\t}\n}\n\n\nexport default MysqlDatabase;\n\n"]}