{"version":3,"sources":["../src/MysqlDatabase.js"],"names":["masterConfig","masterDbh","connectionPool","trxContext","createNamespace","MysqlDatabase","config","_config","_db","_createdFromPool","createConnection","_transacted","cb","getConnection","err","dbh","console","log","debugSQL","_seq","parseInt","Math","random","on","sequence","sql","connect","future","return","wait","end","trxDb","destroy","setTimeout","process","exit","query","values","Promise","resolve","reject","res","q","rows","querySync","length","reuseConnection","connectSync","run","set","ex","rollback","commit","release","removeHandlers","removeListener","_closeAndExit","trxDbh","get","createPool"],"mappings":"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","file":"MysqlDatabase.js","sourcesContent":["import Future from 'fibers/future';\nimport lodashMerge from 'lodash/merge';\nimport mysql from 'mysql';\nimport ContextStorage from 'continuation-local-storage';\n\n/**\n * The MySQL connection wrapper which provides the following features:\n * - \"master\" db connection factory function\n * - sync queries (using Future)\n * - async queries (using Promises - not tested yet)\n * - nested transactions support (in progress)\n * - connection pooling for transaction\n * - local context of \"master\" db connection inside the transaction\n *\n */\n\nlet masterConfig = {};\nlet masterDbh = null;\n\n// Connection pool\n// If connection pool has been set up, MysqlDatabase will pick connections from it\nlet connectionPool = null;\n\n// Local dbh context for transaction. Each transaction generates its own local\n// context with its own \"current global\" dbh.\n// During the transactions start, the value is populated with a transaction\n// dbh, so all upcoming masterDbh() calls return the dbh actual for this transaction.\nlet trxContext = ContextStorage.createNamespace('mysql-dbh');\n\n/**\n * The database processing class.\n *\n * Transaction processing\n *\n * The problem is that all queries share the same mysql connection. Thus, even\n * if we have started the transaction, other queries can intervene within it.\n *\n * To avoid this, we create a separate connection when calling code starts\n * transaction. Then we return the new database handle (\"transacted\") to use,\n * and commit/rollback at the end.\n *\n * var dbh = dbh.beginTransaction(); // new dbh is created here\n * ....\n * dbh.commit();\n */\nclass MysqlDatabase {\n\t/**\n\t * config:\n\t * \tuser, password, host - regular mysql connection settings\n\t * \treuseConnection - during a transaction start, don't get a new connection\n\t * \tdebugSQL - log all SQL queries (debug)\n\t * @param config\n\t */\n\tconstructor(config) {\n\t\tthis._config = lodashMerge({}, config);\n\n\t\tthis._db = null;\n\t\tthis._createdFromPool = false;\n\t\tif(!connectionPool) {\n\t\t\tthis._db = mysql.createConnection(this._config);\n\t\t}\n\n\t\tthis._transacted = 0;\n\t}\n\n\tconnect(cb) {\n\t\tif(connectionPool) {\n\t\t\tconnectionPool.getConnection((err, dbh) => {\n\t\t\t\tconsole.log(\"connection taken from pool\");\n\t\t\t\tthis._createdFromPool = true;\n\t\t\t\tthis._db = dbh;\n\n\t\t\t\t// SQL logging\n\t\t\t\tif(this._config.debugSQL) {\n\t\t\t\t\tif(!this._db._seq) {\n\t\t\t\t\t\tthis._db._seq = parseInt(Math.random() * 100000);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._db.on('enqueue', function(sequence) {\n\t\t\t\t\t\tconsole.log(\"QUERY (\" + this._seq + \"): \", sequence.sql);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif(cb) { cb(err); }\n\t\t\t});\n\t\t} else {\n\t\t\tthis._db.connect(cb);\n\t\t}\n\t}\n\n\tconnectSync() {\n\t\tconst future = new Future();\n\t\tthis.connect((err) => {\n\t\t\tif(err) {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\tfuture.return();\n\t\t});\n\n\t\treturn future.wait();\n\t}\n\n\tdisconnect() {\n\t\tthis._db.end();\n\t}\n\n\tcloseAndExit() {\n\t\ttrxDb.destroy();\n\t\tsetTimeout(() => { process.exit(); }, 500);\n\t}\n\n\tquery(query, values, cb) {\n\t\treturn this._db.query(query, values, cb);\n\t}\n\n\tqueryAsync(query, values) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.query(query, values, (err, res) => {\n\t\t\t\tresolve(res);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Runs a select query synchronously and returns the results\n\t * @param query - query to run\n\t * @param values - values to be passed to query\n\t */\n\tquerySync(query, values) {\n\t\tconst future = new Future();\n\n\t\t// console.log(\"query\", this._transacted?\"(TRX)\":\"\", query);\n\n\t\tthis._db.query(query, values, (err, q) => {\n\t\t\tif(err) {\n\t\t\t\tthrow err;\n\t\t\t\tfuture.return(err);\n\t\t\t} else {\n\t\t\t\tfuture.return(q);\n\t\t\t}\n\t\t});\n\n\t\treturn future.wait();\n\t}\n\n\t/**\n\t * A shortcut function to get a single rows without messing with row arrays\n\t *\n\t * @param query\n\t * @param values\n\t * @returns {Object} - the object with selected fields or {} of no rows found\n\t */\n\tgetRowSync(query, values) {\n\t\tconst rows = this.querySync(query, values);\n\t\t// It is questionable: should we return {} or null below? Which is easier to use?\n\t\t// {} seems to be safer to use, no null.field error will fire\n\t\tif(rows.length === 0) { return {}; }\n\n\t\treturn rows[0];\n\t}\n\n\t/**\n\t * Begins the database transaction.\n\t *\n\t * options:\n\t * \treuseConnection - use the same connection (debug)\n\t *\n\t * @param {Function} cb - the callback to call. Should return 'false' if\n\t * \ttransaction should be rolled back\n\t */\n\texecTransaction(cb) {\n\t\t// TODO GG: port the nested trasactions code here\n\t\t// Create another connection\n\t\t//const trxDb = new MysqlDatabase(mysql.createConnection(Meteor.settings.mysql));\n\t\tlet trxDb = null;\n\n\t\tif(this._transacted > 0 || this._config.reuseConnection) {\n\t\t\t// In a nested transaction, don't create a new connection\n\t\t\ttrxDb = this;\n\t\t} else {\n\t\t\ttrxDb = new MysqlDatabase(this._config);\n\t\t\ttrxDb._transacted = this._transacted;\n\t\t\ttrxDb.connectSync();\n\t\t}\n\n\t\t// Only execute START TRANSACTION for the first-level trx\n\t\tif(trxDb._transacted++ === 0) {\n\t\t\tconsole.log(\"TRX\");\n\t\t\ttrxDb.querySync(\"START TRANSACTION  /* from trx */\");\n\t\t}\n\n\t\tconsole.log(\"before context\");\n\t\t// Execute transaction and create a running context for it\n\t\ttrxContext.run(() => {\n\t\t\ttrxContext.set(\"dbh\", trxDb);\n\n\t\t\tlet res = false;\n\t\t\ttry {\n\t\t\t\tres = cb(trxDb);\n\t\t\t} catch(ex) {\n\t\t\t\ttrxDb.rollback();\n\t\t\t\tthrow ex;\n\t\t\t}\n\n\t\t\tif(res === false) {\n\t\t\t\ttrxDb.rollback();\n\t\t\t} else {\n\t\t\t\ttrxDb.commit();\n\t\t\t}\n\t\t});\n\n\t\t// If we created a new connection, destroy it\n\t\tif(trxDb != this) {\n\t\t\ttrxDb.destroy();\n\t\t}\n\n\t\treturn trxDb;\n\t}\n\n\t/**\n\t * Commits the current database transaction\n\t */\n\tcommit() {\n\t\tif(this._transacted > 0) {\n\t\t\tthis._transacted--;\n\n\t\t\tif(this._transacted === 0) {\n\t\t\t\tthis.querySync(\"COMMIT /* from trx */\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Rolls back the current database transaction\n\t */\n\trollback() {\n\t\tif(this._transacted > 0) {\n\t\t\tthis._transacted--;\n\n\t\t\tif(this._transacted === 0) {\n\t\t\t\tthis.querySync(\"ROLLBACK\");\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy() {\n\t\t// Connections created from pool are to be released, direct connections destroyed\n\t\tif(this._createdFromPool) {\n\t\t\tthis._db.release();\n\t\t} else {\n\t\t\tthis._db.destroy();\n\t\t}\n\n\t\tthis.removeHandlers();\n\t}\n\n\tremoveHandlers() {\n\t\tprocess.removeListener('SIGTERM', this._closeAndExit);\n\t\tprocess.removeListener('SIGINT', this._closeAndExit);\n\t}\n\n\t_closeAndExit() {\n\t\tsetTimeout(() => { process.exit(); }, 500);\n\t}\n\n\t/**\n\t * The connection configuration for masterDbh\n\t * @param config\n\t */\n\tstatic masterConfig(config) {\n\t\tmasterConfig = config;\n\t}\n\n\t/**\n\t * The connection factory. Creates a global connection to be used by default\n\t */\n\tstatic masterDbh() {\n\t\t// First try to get the local scope dbh of the current transaction\n\t\tconst trxDbh = trxContext.get(\"dbh\");\n\t\tif(trxDbh) {\n\t\t\treturn trxDbh;\n\t\t}\n\n\t\t// If no global dbh exist, create it\n\t\tif(!masterDbh) {\n\t\t\tmasterDbh = new MysqlDatabase(masterConfig);\n\t\t\tmasterDbh.connectSync();\n\t\t}\n\n\t\treturn masterDbh;\n\t}\n\n\n\tstatic masterDbhDestroy() {\n\t\tif(masterDbh) {\n\t\t\tmasterDbh.destroy();\n\t\t\tmasterDbh = null;\n\t\t}\n\t}\n\n\t/**\n\t * Setup the mysql connection pool. All further connectionswill be\n\t * taken from within this pool.\n\t *\n\t * config:\n\t * \tuser, password, host - regular mysql connection settings\n\t * \tconnectionLimit - the size of the connection pool. Pool is used only if poolSize > 0\n\t * @param config\n\t */\n\tstatic setupPool(config) {\n\t\tthis.masterConfig(config);\n\t\tconnectionPool = mysql.createPool(config);\n\t}\n}\n\n\nexport default MysqlDatabase;\n\n"]}