"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MysqlDatabase = require("./MysqlDatabase");

var _MysqlDatabase2 = _interopRequireDefault(_MysqlDatabase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var strcount = require('quickly-count-substrings');

/**
 * Represents the database record class.
**/

var DbRecord = function () {
	_createClass(DbRecord, null, [{
		key: "_table",
		value: function _table() {
			throw "DbRecord can't be created directly";
		}
	}, {
		key: "_locatefield",
		value: function _locatefield() {
			throw "DbRecord can't be created directly";
		}
	}, {
		key: "_keys",
		value: function _keys() {
			return [];
		}

		/**
   * Creates the class instance. If options.${_locatefield()} parameter is specified,
   * reads the data from the database and put them into the internal structures
   * (see _init() and _read())
   * @param {Object} [options]
   */

	}]);

	function DbRecord() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

		_classCallCheck(this, DbRecord);

		/**
   * The database handler to work with
   */
		this._autocommit = true;
		this._raw = {};
		this._changes = {};
		this._super = {}; // To hold the existing access method functions

		this._tableName = this.constructor._table();
		this._locateField = this.constructor._locatefield();

		// Use either locally provided or database handler factory
		if (options.dbh) {
			this._dbh = options.dbh;
		} else {
			this._dbh = _MysqlDatabase2.default.masterDbh();
		}

		this._init(options);
	}

	/**
  * Tries creating an object by locate field/keys. Unlike constructor, does
  * not throw an error for non-existing record and returns null instead.
  * @param options
  */


	_createClass(DbRecord, [{
		key: "autocommit",


		/**
   * Instructs class to either save changes to db after each field update, or
   * accumulate the changes.
   * @param {boolean} auto
   */
		value: function autocommit(auto) {
			if (auto && !this._autocommit) {
				// If there are potential unsaved changes, save them
				this.commit();
			}
			this._autocommit = auto;
		}

		/**
   * Save accumulated changed fields, if any
   */

	}, {
		key: "commit",
		value: function commit() {
			var _this = this;

			var sql = "";

			if (this._raw[this._locateField] !== undefined) {
				sql = "UPDATE ";
			} else {
				sql = "INSERT INTO ";
			}

			sql += this._tableName + " SET ";
			var fields = [];
			var values = [];
			Object.keys(this._changes).forEach(function (field) {
				fields.push(field + "=?");
				values.push(_this._raw[field]);
			});

			sql += fields.join(",");

			if (this._raw[this._locateField] !== undefined) {
				sql += " WHERE " + this._locateField + "=?";
				values.push(this._raw[this._locateField]);
			}

			var res = this._dbh.querySync(sql, values);
			// During the first insert the ${_locatefield()} field will be empty, and,
			// probably, generated by mysql
			if (this._raw[this._locateField] === undefined) {
				this._raw[this._locateField] = res.insertId;

				if (this[this._locateField] === undefined) {
					this._createAccessMethod(this._locateField);
				}
			}
		}

		/**
   * Initializes class from the database or as an empty record.
   *
   * If 'options' contains a property named as _locatefield() defines, then we
   * try to initialize from the database. Exception is thrown if there's no
   * record found.
   *
   * @param options
   * @protected
   */

	}, {
		key: "_init",
		value: function _init(options) {
			var byKey = null;
			var keyArgs = [];

			this.constructor._keys().sort(commaSort).forEach(function (k) {
				// console.log("key", k);
				if (byKey != null) {
					return;
				}

				// Check if all key parts are present
				var fits = true;
				k.split(",").forEach(function (kpart) {
					if (!(kpart in options)) {
						fits = false;
					}
				});

				if (fits) {
					// Key fits, remember it and its arguments
					byKey = k.split(",");
					byKey.forEach(function (kpart) {
						keyArgs.push(options[kpart]);
					});
				}
			});

			// if "_locateField" is set, then we need to read our data from the database
			if (options[this._locateField]) {
				this._read(options[this._locateField]);
			} else if (byKey) {
				this._readByKey(byKey, keyArgs);
			} else {
				// else create a new record: read the table info and build access methods
				this._initEmpty();
				this.autocommit(false);
			}
		}

		/**
   * Reads values from the database, puts them into _raw and creates a function
   * to get each value, so we can access fields as:
   * obj.field();
   * obj.field("new value");
   * @protected
   * @param {*} locateValue - the database unique id of the record
   * @param {String} byKey - the field to search on. $_locateField by default.
   */

	}, {
		key: "_read",
		value: function _read(locateValue, byKey) {
			var field = byKey || this._locateField;

			var rows = this._dbh.querySync("SELECT * FROM " + this._tableName + " WHERE " + field + "=? LIMIT 1", [locateValue]);
			return this._createFromRows(rows);
		}

		/**
   * Does the same work as _read, but accepts the secondary keys and values arrays
   * @param keys {Array}
   * @param values {Array}
   * @private
   */

	}, {
		key: "_readByKey",
		value: function _readByKey(keys, values) {
			var fields = keys.join("=? AND ") + "=?";

			var rows = this._dbh.querySync("SELECT * FROM " + this._tableName + " WHERE " + fields + " LIMIT 1", values);
			return this._createFromRows(rows);
		}

		/**
   * Initialize object and methods from rows array
   * @param rows
   * @private
   */

	}, {
		key: "_createFromRows",
		value: function _createFromRows(rows) {
			var _this2 = this;

			if (rows.length == 0) {
				throw new Error("E_DB_NO_OBJECT");
			}

			this._raw = rows[0];

			// Create access methods for all fields
			Object.keys(this._raw).forEach(function (field) {
				_this2._createAccessMethod(field);
			});
		}

		/**
   * Initializes an empty object
   * @private
   */

	}, {
		key: "_initEmpty",
		value: function _initEmpty() {
			var _this3 = this;

			var rows = this._dbh.querySync("DESCRIBE " + this._tableName);
			rows.forEach(function (field) {
				_this3._createAccessMethod(field.Field);
			});
		}

		/**
   * The template for access methods. Reads or sets the value of the object field.
   * @param field
   * @param value
   * @private
   */

	}, {
		key: "_accessField",
		value: function _accessField(field, value) {
			// To set NULL field: class.field(null)
			if (value !== undefined) {
				this._changes[field] = true;
				this._raw[field] = value;

				if (this._autocommit) {
					this.commit();
				}
			}

			return this._raw[field];
		}

		/**
   * Creates a function within this class to get/set the certain field
   * @param field
   * @private
   */

	}, {
		key: "_createAccessMethod",
		value: function _createAccessMethod(field) {
			var _this4 = this;

			console.log("creating", field, _typeof(this[field]));
			var f = function f() {
				var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
				return _this4._accessField(field, value);
			};

			// If access function already exists, do not overwrite it. Instead, add a function
			// to this._super object
			if (typeof this[field] === "function") {
				this._super[field] = f;
			} else {
				this[field] = f;
			}
		}

		/**
   * Removes the record from the database. No verification or integrity checks
   * are being performed, they are up to caller.
   */

	}, {
		key: "deleteRecord",
		value: function deleteRecord() {
			this._dbh.querySync("DELETE FROM " + this._tableName + " WHERE " + this._locateField + " = ?", [this[this._locateField]()]);
		}

		/**
   * Runs through database objects according the options, and calls the
   * callback routine for each.
   *
   * @param options
   * @param {Function} cb - the callback function, it receives two arguments:
   * 	the current iteration DbRecord and the "options" object
   */

	}], [{
		key: "tryCreate",
		value: function tryCreate() {
			var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

			try {
				return new this(options);
			} catch (ex) {
				if (ex.message == "E_DB_NO_OBJECT") {
					return null;
				} else {
					throw ex;
				}
			}
		}
	}, {
		key: "forEach",
		value: function forEach(options, cb) {
			var _this5 = this;

			var sql = "SELECT " + this._locatefield() + " FROM " + this._table();
			var where = [];
			var qparam = [];

			// WHERE fields
			Object.keys(options).forEach(function (k) {
				if (k.match(/[^a-z0-9._]/)) {
					return;
				}

				where.push(k + "=?");
				qparam.push(options[k]);
			});

			if (where.length > 0) {
				sql += " WHERE " + where.join(" AND ");
			}

			// ORDER BY
			if (options.ORDERBY && !options.ORDERBY.match(/[^a-zA-Z0-9 ><-]/)) {
				sql += " ORDER BY " + options.ORDERBY;
			}

			// LIMIT
			if (options.LIMIT && !options.LIMIT.toString().match(/[^0-9, ]/)) {
				sql += " LIMIT " + options.LIMIT;
			}

			if (options.DEBUG_SQL_QUERY) {
				console.log(sql);
			}

			//
			// Iterate
			var _dbh = _MysqlDatabase2.default.masterDbh();
			var rows = _dbh.querySync(sql, qparam);
			options.TOTAL = rows.length;

			if (cb) {
				options.COUNTER = 0;

				rows.forEach(function (row) {
					options.COUNTER++;

					var o = {};
					o[_this5._locatefield()] = row[_this5._locatefield()];
					var obj = new _this5(o);

					cb(obj, options);
				});
			} else {
				options.COUNTER = options.TOTAL;
			}

			return options.COUNTER;
		}
	}]);

	return DbRecord;
}();

/**
 * The sorting function to get entries with more commas first
 * @param a
 * @param b
 */


exports.default = DbRecord;
function commaSort(a, b) {
	var ca = strcount(a, ",");
	var cb = strcount(b, ",");
	return ca > cb ? -1 : 1;
}
//# sourceMappingURL=DbRecord.js.map