"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _MysqlDatabase = require("./MysqlDatabase");

var _MysqlDatabase2 = _interopRequireDefault(_MysqlDatabase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Represents the database record class.
**/
var DbRecord = function () {
	_createClass(DbRecord, [{
		key: "_keys",
		value: function _keys() {
			return [];
		}

		/**
   * Creates the class instance. If options._locatefield parameter is specified,
   * reads the data from the database and put them into the internal structures
   * (see _init() and _read())
   * @param {Object} [options]
   */

	}]);

	function DbRecord() {
		var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

		_classCallCheck(this, DbRecord);

		/**
   * The database handler to work with
   */
		this._autocommit = true;
		this._raw = {};
		this._changes = {};

		this._tableName = this._table();
		this._locatefield = this._locatefield();

		// Use either locally provided or database handler factory
		if (options.dbh) {
			this._dbh = options.dbh;
		} else {
			this._dbh = _MysqlDatabase2.default.masterDbh();
		}

		this._init(options);
	}

	/**
  * Tries creating an object by locate field/keys. Unlike constructor, does
  * not throw an error for non-existing record and returns null instead.
  * @param options
  */


	_createClass(DbRecord, [{
		key: "autocommit",


		/**
   * Instructs class to either save changes to db after each field update, or
   * accumulate the changes.
   * @param {boolean} auto
   */
		value: function autocommit(auto) {
			if (auto && !this._autocommit) {
				// If there are potential unsaved changes, save them
				this.commit();
			}
			this._autocommit = auto;
		}

		/**
   * Save accumulated changed fields, if any
   */

	}, {
		key: "commit",
		value: function commit() {
			var _this = this;

			var sql = "";

			if (this._raw[this._locatefield] !== undefined) {
				sql = "UPDATE ";
			} else {
				sql = "INSERT INTO ";
			}

			sql += this._tableName + " SET ";
			var fields = [];
			var values = [];
			Object.keys(this._changes).forEach(function (field) {
				fields.push(field + "=?");
				values.push(_this._raw[field]);
			});

			sql += fields.join(",");

			if (this._raw[this._locatefield] !== undefined) {
				sql += " WHERE " + this._locatefield + "=?";
				values.push(this._raw[this._locatefield]);
			}

			var res = this._dbh.querySync(sql, values);
			// During the first insert the _locatefield field will be empty, and,
			// probably, generated by mysql
			if (this._raw[this._locatefield] === undefined) {
				this._raw[this._locatefield] = res.insertId;
				this._createAccessMethod(this._locatefield);
			}
		}

		/**
   * Initializes class from the database or as an empty record.
   *
   * If 'options' contains a property named as _locatefield() defines, then we
   * try to initialize from the database. Exception is thrown if there's no
   * record found.
   *
   * @param options
   * @protected
   */

	}, {
		key: "_init",
		value: function _init(options) {
			var byKey = null;
			this._keys().forEach(function (k) {
				if (options[k]) {
					byKey = k;
				}
			});

			// if "_locatefield" is set, then we need to read our data from the database
			if (options[this._locatefield]) {
				this._read(options[this._locatefield]);
			} else if (byKey) {
				this._read(options[byKey], byKey);
			} else {
				// else create a new record: read the table info and build access methods
				this._initEmpty();
				this.autocommit(false);
			}
		}

		/**
   * Reads values from the database, puts them into _raw and creates a function
   * to get each value, so we can access fields as:
   * obj.field();
   * obj.field("new value");
   * @protected
   * @param {*} locateValue - the database unique id of the record
   * @param {String} byKey - the field to search on. $_locatefield by default.
   */

	}, {
		key: "_read",
		value: function _read(locateValue, byKey) {
			var _this2 = this;

			var field = byKey || this._locatefield;

			var rows = this._dbh.querySync("SELECT * FROM " + this._tableName + " WHERE " + field + "=? LIMIT 1", [locateValue]);
			if (rows.length == 0) {
				throw new Error("E_DB_NO_OBJECT");
			}

			this._raw = rows[0];

			// Create access methods for all fields
			Object.keys(this._raw).forEach(function (field) {
				_this2._createAccessMethod(field);
			});
		}

		/**
   * Initializes an empty object
   * @private
   */

	}, {
		key: "_initEmpty",
		value: function _initEmpty() {
			var _this3 = this;

			var rows = this._dbh.querySync("DESCRIBE " + this._tableName);
			rows.forEach(function (field) {
				_this3._createAccessMethod(field.Field);
			});
		}

		/**
   * The template for access methods. Reads or sets the value of the object field.
   * @param field
   * @param value
   * @private
   */

	}, {
		key: "_accessField",
		value: function _accessField(field, value) {
			// We use the magic "\0" instead of undefined for non-set value, because we may need
			// to set NULL field: class.field(null)
			if (value !== "\0") {
				this._changes[field] = true;
				this._raw[field] = value;

				if (this._autocommit) {
					this.commit();
				}
			}

			return this._raw[field];
		}

		/**
   * Creates a function within this class to get/set the certain field
   * @param field
   * @private
   */

	}, {
		key: "_createAccessMethod",
		value: function _createAccessMethod(field) {
			var _this4 = this;

			this[field] = function () {
				var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "\0";
				return _this4._accessField(field, value);
			};
		}
	}], [{
		key: "tryCreate",
		value: function tryCreate() {
			var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

			try {
				return new this(options);
			} catch (ex) {
				if (ex.message == "E_DB_NO_OBJECT") {
					return null;
				} else {
					throw ex;
				}
			}
		}
	}]);

	return DbRecord;
}();

exports.default = DbRecord;
//# sourceMappingURL=DbRecord.js.map